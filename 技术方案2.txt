# Self-Driving Yield Engine v2.0 â€” å®Œæ•´æŠ€æœ¯æ–¹æ¡ˆ
# (å¯¹æ ‡ DoraHacks Riquid Hackathon)
**ç‰ˆæœ¬**: v2.0
**æ—¥æœŸ**: 2026-02-22
**åŸºäº**: æŠ€æœ¯æ–‡æ¡£1.TXT è¯„ä¼° + æœ€æ–°æŠ€æœ¯ç ”ç©¶ + ç«å“åˆ†æ



é»‘å®¢æ¾ç½‘å€ï¼šhttps://dorahacks.io/hackathon/riquid-hackathon/detail

é¢˜ç›®ï¼š

Introduction
How might we build a fully decentralized, non-custodial protocol that leverages AsterDEX to automate superior financial outcomes?

The goal of this hackathon is simple but ambitious: be smarter than the market.

Humans are slow. They sleep. They miss arbitrage opportunities. They hesitate during volatility and allow gas fees, latency, and emotional decision-making to erode returns. Smart contracts, by contrast, are fast, deterministic, and always on.

The BNB Chain Yield Strategy Hackathon: The Self-Driving Yield Engine invites experienced DeFi builders to design and implement production-grade yield infrastructure on BNB Chain â€” a fully autonomous system where smart contracts, not humans, manage capital.

At the core of every submission must be AsterDEX Earn, serving as the primary yield primitive and capital anchor. From there, builders are encouraged to construct composable strategies that programmatically deploy, compound, hedge, and rebalance capital across on-chain venues such as PancakeSwap LPs, farms, and other DeFi primitives â€” all with a focus on risk-adjusted returns and long-term sustainability.

This is an outcome-oriented hackathon. Winning projects are not only rewarded with prizes but may be acquired for long-term deployment, including full intellectual property and copyright transfer. As such, submissions are expected to meet a high bar for security, architecture, and economic design.

The Four Pillars of the Engine
Every submission must implement a contract-governed system grounded in the following core principles:

Integrate (The Core) : AsterDEX Earn must be the primary yield source and the default execution engine for the strategy.
Stack (The Growth) : The system should be designed for composability, enabling yield stacking by re-deploying earned yield into PancakeSwap LPs, farms, or other on-chain strategies to maximize risk-adjusted returns.
Automate (The Speed) : All strategy cycles must be entirely programmatic and deterministic. There can be no manual buttons, multisig execution, privileged operators, or off-chain triggers.
Protect (The Trust) : The architecture must be 100% non-custodial and decentralized. Smart contracts must be the sole source of truth, with no admin keys or entities holding unilateral control over user funds.
Design Prompts: Thinking Outside the Box
To encourage original thinking beyond standard vault designs, participants are invited to explore the following architectural challenges:

Hedging - Can AsterDEX Earn be used not only as a yield source, but also as a hedging mechanism to protect liquidity positions on PancakeSwap?
Volatility - How can your engine leverage flash loans, rapid rebalancing, or atomic execution to turn market volatility into a strategic advantage?
Resilience - How does your system behave during market stress or sharp drawdowns? Does it preserve capital, adapt defensively, or intentionally profit from downside conditions?
If you believe the future of DeFi belongs to self-driving protocols â€” autonomous, composable, and resilient by design â€” this hackathon is built for you.

Prizes
Total Prize Pool: $75,000

ğŸ¥‡ Grand Prize: $50,000
Awarded upon winner selection and initial review
ğŸ Post-Audit Completion Award: $25,000
Released after an independent audit and resolution of all critical and high-severity issues
Winning submissions will be considered for long-term adoption and acquisition.

Eligibility
Open to developers and teams worldwide
Submissions must be built on BNB Chain
The solution must integrate AsterDEX Earn as the primary yield engine
Projects must be fully autonomous, non-custodial, and decentralized
No manual execution, multisig control, or off-chain automation is allowed
Code Quality Requirement
Submissions must include a well-managed private GitHub repository
The repository should demonstrate clear commit history, meaningful commit messages, and structured pull requests (PRs)
This repository will be used for code review, security evaluation, and architectural assessment
Submission Requirements
To be eligible for the Grand Prize, each submission must include the following:

1. The Code
A private GitHub repository
Repository access must be shared with:
cryptocoder0x
tggeth
Additional access may be required during the audit and review process
Submissions with disorganized structure, unclear logic, or â€œspaghetti codeâ€ may be disqualified.

2. The Demo
A demo video with a maximum length of 3 minutes
The video must clearly show the Self-Driving Yield Engine operating autonomously
Demonstrate actual execution and automation
Do not rely solely on slides or explanations
Show the system running and making decisions on its own
3. The Philosophy of Design
A README.md included in the repository that explains:
Why the system was designed the way it was
The core strategy and execution logic
Key assumptions that were questioned or challenged
How the design prioritizes sustainability, resilience, and elegance
Judging Criteria
Submissions will be evaluated across the following dimensions:

Strategy Design & Creativity - 30%
Technical Execution & Automation - 25%
Security & Non-Custodial Integrity - 20%
Economic Design & Sustainability - 15%
Documentation & Clarity - 10%
Judges will prioritize systems that demonstrate autonomy, composability, resilience, and thoughtful economic design.

Contact Us
For questions, technical clarifications, or support:

Telegram: cryptocoder0x
Email: rohit@riquid.io
About Us
This hackathon is organized by the Riquid Team, a DeFi-focused group building advanced yield and capital efficiency infrastructure across on-chain ecosystems.

Riquid is committed to enabling autonomous, trust-minimized financial systems that remove human latency, reduce operational risk, and unlock superior risk-adjusted returns through composable DeFi primitives.

We believe the next evolution of DeFi will be driven by self-driving protocols â€” transparent, deterministic, and resilient by design.







---

## ç›®å½•
- [ç¬¬ä¸€éƒ¨åˆ†ï¼šé¢˜ç›®åˆ†æä¸æŠ€æœ¯æ–‡æ¡£1è¯„ä¼°](#part1)
- [ç¬¬äºŒéƒ¨åˆ†ï¼šç«å“åˆ†æ](#part2)
- [ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ ¸å¿ƒåˆ›æ–°â€”â€”ALPåŒé‡å¼•æ“](#part3)
- [ç¬¬å››éƒ¨åˆ†ï¼šç³»ç»Ÿæ¶æ„](#part4)
- [ç¬¬äº”éƒ¨åˆ†ï¼šæ ¸å¿ƒåˆçº¦è®¾è®¡](#part5)
- [ç¬¬å…­éƒ¨åˆ†ï¼šæ ¸å¿ƒç®—æ³•](#part6)
- [ç¬¬ä¸ƒéƒ¨åˆ†ï¼šçŠ¶æ€æœºä¸èµ„é‡‘æµ](#part7)
- [ç¬¬å…«éƒ¨åˆ†ï¼šå®‰å…¨æ¨¡å‹](#part8)
- [ç¬¬ä¹éƒ¨åˆ†ï¼šç»æµæ¨¡å‹ä¸æ”¶ç›Šæ¨¡æ‹Ÿ](#part9)
- [ç¬¬åéƒ¨åˆ†ï¼šæµ‹è¯•è®¡åˆ’](#part10)
- [ç¬¬åä¸€éƒ¨åˆ†ï¼šéªŒæ”¶æ¡ä»¶](#part11)
- [ç¬¬åäºŒéƒ¨åˆ†ï¼šæ–½å·¥ä»»åŠ¡æ‹†åˆ†](#part12)

---

<a id="part1"></a>
# ç¬¬ä¸€éƒ¨åˆ†ï¼šé¢˜ç›®åˆ†æä¸æŠ€æœ¯æ–‡æ¡£1è¯„ä¼°

## 1.1 é»‘å®¢æ¾å››å¤§æ”¯æŸ±ï¼ˆåŸé¢˜ç²¾è¯»ï¼‰

```
+============+=====================================================+
| Integrate  | AsterDEX Earn = ä¸»æ”¶ç›Šæº + é»˜è®¤æ‰§è¡Œå¼•æ“             |
| (æ ¸å¿ƒ)     | -> å¿…é¡»æ˜¯ primary yield source                      |
+============+=====================================================+
| Stack      | å¯ç»„åˆæ€§ï¼šå°†æ”¶ç›Šå†éƒ¨ç½²åˆ° PancakeSwap LP/farms        |
| (å¢é•¿)     | -> æ”¶ç›Šå †å ï¼Œæœ€å¤§åŒ–é£é™©è°ƒæ•´åå›æŠ¥                    |
+============+=====================================================+
| Automate   | å®Œå…¨ç¨‹åºåŒ– + ç¡®å®šæ€§æ‰§è¡Œ                              |
| (é€Ÿåº¦)     | -> æ— æ‰‹åŠ¨æŒ‰é’®/å¤šç­¾/ç‰¹æƒæ“ä½œå‘˜/é“¾ä¸‹è§¦å‘               |
+============+=====================================================+
| Protect    | 100% éæ‰˜ç®¡ + å»ä¸­å¿ƒåŒ–                               |
| (ä¿¡ä»»)     | -> æ™ºèƒ½åˆçº¦ = å”¯ä¸€çœŸç›¸æºï¼Œæ— ç®¡ç†å‘˜å¯†é’¥               |
+============+=====================================================+
```

### é¢˜ç›®éšè—åŠ åˆ†é¡¹ï¼ˆDesign Promptsï¼‰

é¢˜ç›®é¢å¤–æå‡ºä¸‰ä¸ªè®¾è®¡æŒ‘æˆ˜ï¼Œç›´æ¥å½±å“è¯„åˆ†ï¼ˆStrategy Design 30%ï¼‰ï¼š

1. **Hedging**: AsterDEX Earn ä¸ä»…åšæ”¶ç›Šæºï¼Œè¿˜èƒ½åšå¯¹å†²å·¥å…·ï¼Ÿ
2. **Volatility**: èƒ½å¦åˆ©ç”¨ flash loans / å¿«é€Ÿå†å¹³è¡¡ / åŸå­æ‰§è¡ŒæŠŠæ³¢åŠ¨å˜æˆä¼˜åŠ¿ï¼Ÿ
3. **Resilience**: å¸‚åœºå‹åŠ›/æš´è·Œæ—¶ç³»ç»Ÿå¦‚ä½•è¡¨ç°ï¼Ÿä¿æœ¬ï¼Ÿé˜²å¾¡ï¼Ÿè¿˜æ˜¯åå‘è·åˆ©ï¼Ÿ

### è¯„å®¡æƒé‡

```
Strategy Design & Creativity .............. 30%  <-- æœ€é‡è¦ï¼
Technical Execution & Automation .......... 25%
Security & Non-Custodial Integrity ........ 20%
Economic Design & Sustainability .......... 15%
Documentation & Clarity ................... 10%
```

---

## 1.2 æŠ€æœ¯æ–‡æ¡£1è¯„ä¼°

### ä¼˜åŠ¿ï¼ˆä¿ç•™å¹¶å¢å¼ºï¼‰

| ç¼–å· | ä¼˜åŠ¿ç‚¹ | è¯„ä»· |
|------|--------|------|
| S1 | ALP ä½œä¸ºæ ¸å¿ƒæ”¶ç›Šé”šçš„é€‰æ‹©è®ºè¯å……åˆ† | æ’é™¤äº† asUSDF(æ‰˜ç®¡)ã€asCAKE(åœé“¸)ã€Aster Pro(API key) |
| S2 | 1001x(Simple) åˆçº¦ç›´è¿å¯¹å†² | diamond proxy + facets åˆ†æåˆ°ä½ |
| S3 | PancakeSwap V2 è‡ªåŠ¨å¤åˆ©è®ºè¯ | 0.17% fee å›æ³¨ vs V3 éœ€æ‰‹åŠ¨é¢†å– |
| S4 | ä¸¤æ®µå¼èµå›é˜Ÿåˆ—è®¾è®¡ | æ­£ç¡®å¤„ç† ALP 48h å†·å´ + burn cap |
| S5 | permissionless cycle() + bounty | ç¬¦åˆ"æ— ç‰¹æƒè§¦å‘è€…"è¦æ±‚ |
| S6 | è¯¦ç»†çš„éªŒæ”¶æ¡ä»¶å’Œä»»åŠ¡æ‹†åˆ† | å¯ç›´æ¥äº¤ç»™å¼€å‘è€… |

### ä¸è¶³ï¼ˆå¿…é¡»æ”¹è¿›ï¼‰

| ç¼–å· | ä¸è¶³ç‚¹ | å½±å“ | æ”¹è¿›æ–¹å‘ |
|------|--------|------|----------|
| W1 | æ—  Flash Loan ç­–ç•¥ | é¢˜ç›®æ˜ç¡®é—®äº†, ä¸¢åˆ† | æ·»åŠ åŸå­å†å¹³è¡¡ |
| W2 | æ— æ³¢åŠ¨ç‡è‡ªé€‚åº” | Resilience ç¼ºå¤± | æ·»åŠ  Regime Switching |
| W3 | å›ºå®š 80/20 åˆ†é… | ä¸å¤Ÿæ™ºèƒ½ | åŠ¨æ€ APR-proportional |
| W4 | æœªåˆ©ç”¨ ALP åšå¯¹å†² | é¢˜ç›®ä¸“é—¨é—®äº†ï¼ | ALP å¤©ç„¶åšç©ºæ³¢åŠ¨ç‡å±æ€§ |
| W5 | æ—  MEV ä¿æŠ¤ | å®‰å…¨ 20% å—å½±å“ | æ·»åŠ æ»‘ç‚¹ä¿æŠ¤+deadline |
| W6 | æ— ç»æµæ¨¡å‹/æ¨¡æ‹Ÿ | Economic 15% ä¸¢åˆ† | æ·»åŠ æ”¶ç›Šæ¨¡æ‹Ÿ |
| W7 | bounty æœºåˆ¶è¿‡äºç®€å• | æ¿€åŠ±ä¸è¶³ | åˆ©æ¶¦åˆ†æˆæ¨¡å‹ |
| W8 | ä»…æ”¯æŒå•ä¸€äº¤æ˜“å¯¹ | é™åˆ¶çµæ´»æ€§ | å¤š pair é…ç½® |
| W9 | æ— ç´§æ€¥é€€å‡ºæœºåˆ¶ | æç«¯è¡Œæƒ…æ— ä¿æŠ¤ | circuit breaker |

### è¯„åˆ†é¢„ä¼°å¯¹æ¯”

```
                    æŠ€æœ¯æ–‡æ¡£1    æŠ€æœ¯æ–¹æ¡ˆ2(æœ¬æ–‡æ¡£)
Strategy Design      5/10        9/10  (+Flash Loan, +ALPå¯¹å†², +Regime)
Technical Execution  7/10        8/10  (+åŸå­æ“ä½œ, +å¤šå±‚æ¶æ„)
Security             6/10        8/10  (+MEVä¿æŠ¤, +circuit breaker)
Economic Design      3/10        7/10  (+ç»æµæ¨¡å‹, +æ”¶ç›Šæ¨¡æ‹Ÿ)
Documentation        7/10        8/10  (+ç«å“åˆ†æ, +è®¾è®¡å“²å­¦)
----------------------------------------------------
åŠ æƒæ€»åˆ†             5.4/10      8.2/10
```



---

<a id="part2"></a>
# ç¬¬äºŒéƒ¨åˆ†ï¼šç«å“åˆ†æ

## 2.1 å·²æäº¤é¡¹ç›®åˆ†æ

### ç«å“ A: Riquid (buidl/38889)

```
ç­–ç•¥æ¶æ„:
  ç”¨æˆ· USDC --> Vault
                 |
                 v
         AsterDEX BNB/USDC LP
                 |
          +------+------+
          |             |
          v             v
    40% Stable     60% Staking
    Vault(å¯¹å†²)    (å¢é•¿+å¤åˆ©)
```

**ä¼˜ç‚¹**:
- æ¦‚å¿µæ¸…æ™°ï¼šç”¨å¥–åŠ±åˆ†é…æ¥è¡¥å¿ ILï¼Œè€Œéæ–¹å‘æ€§é¢„æµ‹
- æ•°å­¦åŸºç¡€æ‰å®ï¼šç”¨æ ‡å‡† AMM IL å…¬å¼é‡åŒ–
- Hedge Efficiency = (Hedge Rewards / |IL Amount|) x 100
- å£°ç§° 100%+ IL è¦†ç›–ç‡

**ç¼ºç‚¹**:
- åªç”¨ AsterDEX ä¸€ä¸ªåè®®ï¼Œæœªæ¥ PancakeSwapï¼ˆStack å±‚å¼±ï¼‰
- å¯¹å†²é "å¥–åŠ±æ‹†åˆ†"è€ŒéçœŸæ­£çš„é‡‘èå¯¹å†²ï¼ˆåšç©º/æœŸæƒï¼‰
- æ—  Flash Loan / æ—  Regime Switching
- åªæœ‰ä¸€ä¸ª LP pair (BNB/USDC)
- æ— é“¾ä¸Šæ³¢åŠ¨ç‡æ£€æµ‹

**è¯„ä¼°**: Strategy Design 6/10, å®ç°ç®€å•ä½†åˆ›æ–°æ€§ä¸è¶³

---

### ç«å“ B: MetaYieldVault (buidl/39626)

```
ç­–ç•¥æ¶æ„:
  ç”¨æˆ· USDT --> MetaYieldVault (ERC4626, MYV shares)
                 |
       +---------+---------+
       |         |         |
       v         v         v
    60% Earn   35% LP    5% Buffer
    asUSDF    CAKE/WBNB    USDT
    6-9% APY  +MasterChef
              +CAKE emissions
                 |
                 v
          Aster Perps
          BNB short (delta-hedge)
```

**ä¼˜ç‚¹**:
- ä¸‰å±‚æ”¶ç›Šæ¶æ„ï¼ˆEarn + LP + Perp Hedgeï¼‰
- APR-proportional åŠ¨æ€åˆ†é…ï¼ˆéå›ºå®šæ¯”ä¾‹ï¼‰
- Regime Switching: NORMAL / DEFENSIVE / AGGRESSIVE
- Gas-gated è‡ªåŠ¨ harvestï¼ˆåªåœ¨æœ‰åˆ©å¯å›¾æ—¶æ‰§è¡Œï¼‰
- TaskerOnChain keeper ç½‘ç»œï¼ˆé“¾ä¸Šä»»åŠ¡è°ƒåº¦ï¼‰

**ç¼ºç‚¹**:
- ç”¨äº† asUSDFï¼ˆæ¶‰åŠ Ceffu MirrorX æ‰˜ç®¡ï¼Œä¸"non-custodial"å†²çªï¼‰
- MasterChef farming éœ€è¦ harvest CAKEï¼ˆé“¾ä¸‹ Merkle äº‰è®®ï¼‰
- TaskerOnChain æ˜¯é¢å¤–ä¾èµ–ï¼ˆkeeper ç½‘ç»œ = åŠé“¾ä¸‹ï¼‰
- æ—  Flash Loan ç­–ç•¥
- å¤æ‚åº¦é«˜ä½†æœªè§å®‰å…¨å®¡è®¡è€ƒè™‘

**è¯„ä¼°**: Strategy Design 8/10, ä½† non-custodial æœ‰ç¡¬ä¼¤ï¼ˆasUSDFï¼‰

---

## 2.2 æˆ‘ä»¬çš„å·®å¼‚åŒ–å®šä½

```
å·®å¼‚åŒ–çŸ©é˜µ:
+--------------------+--------+---------------+----------+
| ç‰¹æ€§               | Riquid | MetaYieldVault| æˆ‘ä»¬(v2) |
+--------------------+--------+---------------+----------+
| ALP ä½œä¸ºä¸»é”š       |   X    |    X(asUSDF)  |    O     |
| çœŸæ­£ non-custodial |   O    |    X(Ceffu)   |    O     |
| Delta Hedge        |   X    |    O          |    O     |
| Flash Loan å†å¹³è¡¡  |   X    |    X          |    O     |
| Regime Switching   |   X    |    O          |    O     |
| ALP åšå¯¹å†²(åˆ›æ–°)   |   X    |    X          |    O     |
| PancakeSwap V2 LP  |   X    |    O(V2)      |    O     |
| åŠ¨æ€åˆ†é…           |   X    |    O          |    O     |
| MEV ä¿æŠ¤           |   X    |    X          |    O     |
| æ— å¤–éƒ¨ keeperä¾èµ–  |   X    |    X(Tasker)  |    O     |
+--------------------+--------+---------------+----------+
  O = æœ‰    X = æ²¡æœ‰
```

### æˆ‘ä»¬çš„ä¸‰å¤§æ ¸å¿ƒåˆ›æ–°:

1. **ALP åŒé‡å¼•æ“** (Yield + Volatility Hedge) â€” ä¸šç•Œé¦–åˆ›
2. **Flash Loan åŸå­å†å¹³è¡¡** â€” ç›´å‡»é¢˜ç›® Design Prompt
3. **é“¾ä¸Šæ³¢åŠ¨ç‡ Oracle + ä¸‰æ¡£ Regime** â€” æ—  Chainlink ä¾èµ–



---

<a id="part3"></a>
# ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ ¸å¿ƒåˆ›æ–° â€” ALP åŒé‡å¼•æ“ï¼ˆæ”¶ç›Š + æ³¢åŠ¨ç‡å¯¹å†²ï¼‰

## 3.1 ALP æ”¶ç›Šæœºåˆ¶æ·±åº¦åˆ†æ

ALP (Aster Liquidity Provider) ä¸º Aster 1001x(Simple) çš„æ‰€æœ‰äº¤æ˜“å¯¹æä¾›æµåŠ¨æ€§ã€‚

```
ALP æ”¶ç›Šæ¥æºåˆ†è§£:
+========================+
|    ALP NAV å¢é•¿        |
+========================+
         |
   +-----+-----+-----+-----+
   |     |     |     |     |
   v     v     v     v     v
 åšå¸‚  äº¤æ˜“  èµ„é‡‘  æ¸…ç®—  ä»·æ ¼
 PnL  æ‰‹ç»­è´¹ è´¹ç‡  æ”¶ç›Š  åå·®
```

- **åšå¸‚ PnL**: ä½œä¸ºæ‰€æœ‰ 1001x äº¤æ˜“è€…çš„å¯¹æ‰‹æ–¹ï¼Œç»Ÿè®¡ä¸Š"åº„å®¶"é•¿æœŸç›ˆåˆ©
- **Trading Fees**: æ¯ç¬” 1001x äº¤æ˜“çš„ 0.08% å¼€/å¹³ä»“è´¹
- **Funding Fees**: æ°¸ç»­åˆçº¦æŒ‰ block è®¡æçš„èµ„é‡‘è´¹ç‡
- **Liquidations**: çˆ†ä»“ç”¨æˆ·çš„ä¿è¯é‡‘å½’å…¥ ALP æ± 
- **ä»·æ ¼åå·®æ”¶å…¥**: ALP mint/burn çš„åŠ¨æ€è´¹ç‡å·®

### ALP å…³é”®å‚æ•°

```
Mint åå†·å´æœŸ:     48 å°æ—¶ï¼ˆä¸å¯ burnï¼‰
Burn ä¸Šé™:         ä¸æ± ä»·å€¼ã€ç”¨æˆ·ä»“ä½ã€ALP ä»·æ ¼ç›¸å…³
Mint/Burn Fee:     åŠ¨æ€ï¼ˆæƒé‡é©±åŠ¨å…¬å¼ï¼‰
NAV è®¡ç®—:          å®æ—¶åæ˜ æ‰€æœ‰ä¸Šè¿°æ”¶ç›Š/äºæŸ
åˆçº¦åœ°å€(BSC):     0x1b6f2d3844c6ae7d56ceb3c3643b9060ba28feb0 (Diamond)
```

---

## 3.2 å…³é”®æ´å¯Ÿï¼šALP çš„å¤©ç„¶"åšç©ºæ³¢åŠ¨ç‡"å±æ€§

è¿™æ˜¯æœ¬æ–¹æ¡ˆçš„**æ ¸å¿ƒåˆ›æ–°**ï¼Œä¹Ÿæ˜¯å›ç­”é¢˜ç›® Design Prompt "Hedging" çš„å…³é”®ã€‚

### æ³¢åŠ¨ç‡ä¸ ALP çš„å…³ç³»

```
å¸‚åœºæ³¢åŠ¨ç‡ UP                    å¸‚åœºæ³¢åŠ¨ç‡ DOWN
     |                                |
     v                                v
+-------------------+          +-------------------+
| äº¤æ˜“é‡ UP         |          | äº¤æ˜“é‡ DOWN       |
| æ¸…ç®—äº‹ä»¶ UP       |          | æ¸…ç®—äº‹ä»¶ DOWN     |
| èµ„é‡‘è´¹ç‡æ³¢åŠ¨ UP   |          | èµ„é‡‘è´¹ç‡ç¨³å®š      |
+-------------------+          +-------------------+
     |                                |
     v                                v
+-------------------+          +-------------------+
| ALP æ‰‹ç»­è´¹æ”¶å…¥ UP |          | ALP æ‰‹ç»­è´¹æ”¶å…¥    |
| ALP æ¸…ç®—æ”¶ç›Š UP   |          |   ä¿æŒç¨³å®š        |
| ALP åšå¸‚ PnL     |          | ALP åšå¸‚ PnL      |
|   (çŸ­æœŸå¯èƒ½äºæŸ   |          |   (ä½æ³¢åŠ¨=ä½é£é™©) |
|    ä½†ç»Ÿè®¡ä¸Šç›ˆåˆ©)  |          |                   |
+-------------------+          +-------------------+
```

### æ ¸å¿ƒè®ºç‚¹

**ALP æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª"Short Volatility + Long Theta"çš„ä»“ä½**ï¼š

1. **ç±»ä¼¼ä¿é™©å…¬å¸**: ALP æŒæœ‰è€…æ˜¯æ‰€æœ‰äº¤æ˜“è€…çš„å¯¹æ‰‹æ–¹ã€‚å°±åƒä¿é™©å…¬å¸æ”¶ä¿è´¹
   å¹¶åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ç›ˆåˆ©ä¸€æ ·ï¼ŒALP æ”¶å–æ‰‹ç»­è´¹å¹¶åœ¨ç»Ÿè®¡ä¸Šè·åˆ©ã€‚

2. **æ³¢åŠ¨ç‡è¶Šé«˜ = æ‰‹ç»­è´¹æ”¶å…¥è¶Šå¤š**: é«˜æ³¢åŠ¨å¸‚åœºâ†’æ›´å¤šäº¤æ˜“â†’æ›´å¤šæ‰‹ç»­è´¹+æ¸…ç®—ã€‚

3. **ä¸ LP çš„ IL å½¢æˆäº’è¡¥**:
   - LP (Pancake V2) åœ¨é«˜æ³¢åŠ¨æ—¶äºæŸï¼ˆIL å¢åŠ ï¼‰
   - ALP åœ¨é«˜æ³¢åŠ¨æ—¶æ”¶å…¥å¢åŠ ï¼ˆæ‰‹ç»­è´¹+æ¸…ç®—ï¼‰
   - ä¸¤è€…å¤©ç„¶å½¢æˆå¯¹å†²å…³ç³»ï¼

### æ•°å­¦è¯æ˜

```
è®¾:
  sigma = å¸‚åœºå¹´åŒ–æ³¢åŠ¨ç‡
  V_lp  = LP ä»“ä½ä»·å€¼
  V_alp = ALP ä»“ä½ä»·å€¼

LP çš„ IL è¿‘ä¼¼ï¼ˆå°æ³¢åŠ¨ï¼‰:
  IL(sigma) ~= -(sigma^2) / 8
  å³ IL ä¸æ³¢åŠ¨ç‡å¹³æ–¹æˆæ­£æ¯”

ALP çš„è¶…é¢æ”¶ç›Šï¼ˆæ¥è‡ªäº¤æ˜“é‡ï¼Œäº¤æ˜“é‡ä¸æ³¢åŠ¨ç‡æ­£ç›¸å…³ï¼‰:
  ExcessReturn_alp(sigma) ~= k * sigma
  å…¶ä¸­ k ä¸ºæ‰‹ç»­è´¹ç³»æ•°ï¼ˆå–å†³äºäº¤æ˜“é‡-æ³¢åŠ¨ç‡å¼¹æ€§ï¼‰

ç»„åˆæ”¶ç›Š:
  Portfolio = w_alp * (baseAPY_alp + k*sigma) + w_lp * (feeAPY_lp - sigma^2/8)

å¯¹ sigma æ±‚å¯¼ = 0 æ‰¾æœ€ä¼˜é…æ¯”:
  dPortfolio/d(sigma) = w_alp * k - w_lp * sigma/4 = 0
  => w_alp / w_lp = sigma / (4k)

ç»“è®º:
  æ³¢åŠ¨ç‡è¶Šé«˜ -> ALP é…æ¯”åº”è¶Šé«˜ -> å¤©ç„¶è‡ªé€‚åº”ï¼
```

---

## 3.3 ALP + LP äº’è¡¥æ€§ï¼šå›ç­” "Can AsterDEX Earn be used as a hedging mechanism?"

```
æ”¶ç›Šä¸æ³¢åŠ¨ç‡çš„å…³ç³»å›¾ (æ¦‚å¿µ):

æ”¶ç›Š
  ^
  |         ALP
  |        /
  |       /     ç»„åˆ(ALP+LP)
  |      /    __---
  |     /  __-
  |    /__-
  |   /-__
  |  /    --__  LP
  | /         --___
  |/                ---___
  +-------------------------> æ³¢åŠ¨ç‡(sigma)

  ä½æ³¢åŠ¨: LP å ä¼˜ï¼ˆILå°ï¼Œè´¹ç”¨ç¨³å®šï¼‰
  é«˜æ³¢åŠ¨: ALP å ä¼˜ï¼ˆæ‰‹ç»­è´¹+æ¸…ç®—æ”¶å…¥æš´å¢ï¼‰
  ç»„åˆ:   å…¨å¤©å€™ç¨³å®šæ­£æ”¶ç›Šï¼
```

### è®¾è®¡åŸåˆ™

> **ALP ä¸åªæ˜¯æ”¶ç›Šæºï¼Œå®ƒæ˜¯æˆ‘ä»¬çš„å†…ç”Ÿå¯¹å†²å·¥å…·ï¼ˆEndogenous Hedgeï¼‰ã€‚**
>
> æˆ‘ä»¬ä¸éœ€è¦å¤–éƒ¨ä¿é™©åè®®ã€ä¸éœ€è¦è´­ä¹°æœŸæƒã€ä¸éœ€è¦é¢„æµ‹å¸‚åœºæ–¹å‘ã€‚
> ALP çš„"åº„å®¶"å±æ€§å¤©ç„¶å¯¹å†²äº† LP çš„ IL é£é™©ã€‚
>
> è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬å«å®ƒ **"åŒé‡å¼•æ“"ï¼ˆDual Engineï¼‰**ï¼š
> - å¼•æ“1: æ”¶ç›Šå¼•æ“ (Yield Engine)
> - å¼•æ“2: å¯¹å†²å¼•æ“ (Hedge Engine)



---

<a id="part4"></a>
# ç¬¬å››éƒ¨åˆ†ï¼šç³»ç»Ÿæ¶æ„

## 4.1 æ€»ä½“æ¶æ„å›¾

```
                        ç”¨æˆ· (USDT)
                           |
                     deposit / redeem
                           |
                           v
                 +====================+
                 |   EngineVault      |
                 |   (ERC-4626)       |
                 |                    |
                 | - shares ç®¡ç†      |
                 | - èµ„äº§ä¼°å€¼          |
                 | - æƒé™=é›¶          |
                 +=========+==========+
                           |
              cycle() [permissionless, anyone can call]
                           |
            +--------------+--------------+
            |              |              |
            v              v              v
  +================+ +===========+ +================+
  | AsterAlp       | | PancakeV2 | | Aster1001x     |
  | Adapter        | | Adapter   | | Adapter        |
  |                | |           | |                |
  | mintAlp()      | | addLiq()  | | openMarket()   |
  | burnAlp()      | | removeLiq | | closeTrade()   |
  | getNAV()       | | getAmts() | | getPositions() |
  +================+ +===========+ +================+
         |                |               |
         v                v               v
  [ALP Token]     [V2 LP Token]    [1001x Perp Pos]
  (AsterDEX)      (PancakeSwap)    (AsterDEX)
                        |
                        v
              +==================+
              | FlashRebalancer  |
              |                  |
              | PancakeSwap V2   |
              | Flash Swap       |
              | (åŸå­å†å¹³è¡¡)     |
              +==================+

  æ¨ªåˆ‡å…³æ³¨ç‚¹:
  +==================+    +==================+
  | VolatilityOracle |    | WithdrawalQueue  |
  | (é“¾ä¸ŠTWAPæ³¢åŠ¨ç‡) |    | (æ— ç®¡ç†å‘˜èµå›)   |
  +==================+    +==================+
```

## 4.2 ä¸‰å±‚æ”¶ç›Šæ¶æ„ï¼ˆå¯¹åº”é¢˜ç›®å››å¤§æ”¯æŸ±ï¼‰

```
+================================================================+
|                    Self-Driving Yield Engine v2                  |
+================================================================+
|                                                                  |
|  LAYER 1: INTEGRATE (æ ¸å¿ƒæ”¶ç›Š) - ALP                            |
|  +---------------------------------------------------------+   |
|  | AsterDEX Earn -> ALP                                     |   |
|  | - åšå¸‚ PnL + Trading Fees + Funding Fees + Liquidations  |   |
|  | - ç›®æ ‡é…æ¯”: åŠ¨æ€ï¼ˆ40%-80%ï¼Œæ³¢åŠ¨ç‡è‡ªé€‚åº”ï¼‰                 |   |
|  | - åŒé‡åŠŸèƒ½: æ”¶ç›Šå¼•æ“ + æ³¢åŠ¨ç‡å¯¹å†²å¼•æ“                    |   |
|  +---------------------------------------------------------+   |
|                                                                  |
|  LAYER 2: STACK (å¢é•¿å±‚) - PancakeSwap V2 LP                   |
|  +---------------------------------------------------------+   |
|  | PancakeSwap V2 -> BTCB/USDT LP                           |   |
|  | - 0.17% äº¤æ˜“è´¹è‡ªåŠ¨å›æ³¨ï¼ˆå¤©ç„¶å¤åˆ©ï¼‰                        |   |
|  | - ç›®æ ‡é…æ¯”: åŠ¨æ€ï¼ˆ15%-50%ï¼Œæ³¢åŠ¨ç‡è‡ªé€‚åº”ï¼‰                 |   |
|  | - Flash Loan åŸå­å†å¹³è¡¡                                   |   |
|  +---------------------------------------------------------+   |
|                                                                  |
|  LAYER 3: PROTECT (ä¿æŠ¤å±‚) - 1001x Delta Hedge                 |
|  +---------------------------------------------------------+   |
|  | Aster 1001x(Simple) -> Short BTCB                        |   |
|  | - å¯¹å†² LP çš„ BTCB æ–¹å‘æ•å£                               |   |
|  | - ä¿è¯é‡‘æ¥è‡ª cashBuffer                                   |   |
|  | - è‡ªåŠ¨åŠ å‡ä»“: netDelta è¶… band æ—¶è°ƒæ•´                    |   |
|  +---------------------------------------------------------+   |
|                                                                  |
|  CROSS-CUTTING: AUTOMATE (è‡ªåŠ¨åŒ–)                               |
|  +---------------------------------------------------------+   |
|  | cycle() -> permissionless, bounty-incentivized           |   |
|  | VolatilityOracle -> é“¾ä¸ŠTWAP, æ— Chainlinkä¾èµ–            |   |
|  | Regime Switching -> CALM / NORMAL / STORM                |   |
|  | Flash Rebalancer -> åŸå­æ“ä½œ, é›¶ä¸´æ—¶æ•å£                  |   |
|  +---------------------------------------------------------+   |
|                                                                  |
+================================================================+
```

## 4.3 ä»“åº“ç›®å½•ç»“æ„

```
/contracts
  /core
    EngineVault.sol          # ERC-4626 vault, cycle(), èµ„äº§ä¼°å€¼
    WithdrawalQueue.sol      # ä¸¤æ®µå¼èµå›ï¼ˆrequest -> claimï¼‰
    VolatilityOracle.sol     # é“¾ä¸Š TWAP æ³¢åŠ¨ç‡è®¡ç®—
  /adapters
    AsterAlpAdapter.sol      # ALP mint/burn/NAV
    Aster1001xAdapter.sol    # 1001x å¼€ä»“/å¹³ä»“/è¯»ä»“ä½
    PancakeV2Adapter.sol     # V2 LP add/remove/è®¡ç®—ä»½é¢
    FlashRebalancer.sol      # Flash Swap åŸå­å†å¹³è¡¡
  /libs
    MathLib.sol              # å®šç‚¹æ•°å­¦ã€sqrtã€abs
    SafeTransferLib.sol      # å®‰å…¨è½¬è´¦
    PriceLib.sol             # ä»·æ ¼è½¬æ¢å·¥å…·
  /interfaces
    IAsterDiamond.sol        # Aster diamond ABIï¼ˆLouper å¯¼å‡ºè£å‰ªï¼‰
    IPancakeRouterV2.sol     # PancakeSwap V2 Router
    IPancakePairV2.sol       # PancakeSwap V2 Pair
    IPancakeFactoryV2.sol    # PancakeSwap V2 Factory
    IERC20.sol               # æ ‡å‡† ERC20
/test
  EngineVault.fork.t.sol     # BSC mainnet fork æµ‹è¯•
  EngineVault.unit.t.sol     # å•å…ƒæµ‹è¯•ï¼ˆmockï¼‰
  FlashRebalancer.fork.t.sol # Flash Loan æµ‹è¯•
  Invariants.t.sol           # ä¸å˜é‡æµ‹è¯•
  Regime.t.sol               # Regime åˆ‡æ¢æµ‹è¯•
/script
  Deploy.s.sol               # éƒ¨ç½²è„šæœ¬
  DemoRun.s.sol              # æ¼”ç¤ºè„šæœ¬ï¼ˆå½• Demo ç”¨ï¼‰
/docs
  README.md                  # è®¾è®¡å“²å­¦ + ä½¿ç”¨æŒ‡å—
  ARCHITECTURE.md            # æ¶æ„è¯¦è§£
  THREAT_MODEL.md            # å¨èƒæ¨¡å‹
  ECONOMICS.md               # ç»æµæ¨¡å‹ä¸æ¨¡æ‹Ÿ
```

## 4.4 å…³é”®åˆçº¦åœ°å€ï¼ˆBSC Mainnet, å·²éªŒè¯ï¼‰

```
Aster 1001x Diamond:      0x1b6f2d3844c6ae7d56ceb3c3643b9060ba28feb0
PancakeSwap Router V2:     0x10ED43C718714eb63d5aA57B78B54704E256024E
PancakeSwap Factory V2:    0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73
WBNB:                      0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c
USDT (BSC):                0x55d398326f99059fF775485246999027B3197955
BTCB (BSC):                0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c

INIT_CODE_PAIR_HASH (V2):  0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5
```



---

<a id="part5"></a>
# ç¬¬äº”éƒ¨åˆ†ï¼šæ ¸å¿ƒåˆçº¦è®¾è®¡

## 5.1 EngineVaultï¼ˆERC-4626 é£æ ¼ï¼‰

### çŠ¶æ€å˜é‡ï¼ˆæ„é€ å‡½æ•°å†™æ­»ï¼Œæ—  admin å¯ä¿®æ”¹ï¼‰

```solidity
// === å¤–éƒ¨åè®®åœ°å€ï¼ˆimmutableï¼‰ ===
IERC20  public immutable asset;          // USDT (BSC)
address public immutable asterDiamond;   // 0x1b6f2d... (1001x)
address public immutable pancakeRouter;  // 0x10ED43C7...
address public immutable pancakeFactory; // 0xcA143Ce3...
address public immutable alpToken;       // ALP token åœ°å€
address public immutable pairBase;       // BTCB åœ°å€ï¼ˆå¯¹å†²æ ‡çš„ï¼‰
address public immutable v2Pair;         // BTCB/USDT V2 Pair

// === ç­–ç•¥å‚æ•°ï¼ˆimmutableï¼Œæ„é€ æ—¶ç¡®å®šï¼‰ ===
uint16 public immutable deltaBandBps;       // 200 (å…è®¸ +-2% deltaåç¦»)
uint16 public immutable cycleBountyBps;     // 20 (bounty = 0.2% of cycle profit)
uint16 public immutable cashBufferBps;      // 300 (3% ç°é‡‘ç¼“å†²)
uint256 public immutable minCycleInterval;  // 300 (5åˆ†é’Ÿæœ€å°é—´éš”)
uint256 public immutable maxTradeNotional;  // å•æ¬¡å¯¹å†²ä¸Šé™

// === Regime å‚æ•°ï¼ˆimmutableï¼‰ ===
uint16 public immutable calmAlpBps;    // 4000 (CALM: 40% ALP)
uint16 public immutable calmLpBps;     // 5700 (CALM: 57% LP)
uint16 public immutable normalAlpBps;  // 6000 (NORMAL: 60% ALP)
uint16 public immutable normalLpBps;   // 3700 (NORMAL: 37% LP)
uint16 public immutable stormAlpBps;   // 8000 (STORM: 80% ALP)
uint16 public immutable stormLpBps;    // 1700 (STORM: 17% LP)
// æ³¨: cashBuffer å§‹ç»ˆ = 10000 - alpBps - lpBps

// === è¿è¡Œæ—¶çŠ¶æ€ ===
uint256 public lastCycleTimestamp;
Regime  public currentRegime;  // enum { CALM, NORMAL, STORM }
uint256 public totalDeployedValue;
```

### å¤–éƒ¨æ¥å£

```solidity
// --- ç”¨æˆ·æ¥å£ ---
function deposit(uint256 assets, address receiver) external returns (uint256 shares);
function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
function requestWithdraw(uint256 shares) external returns (uint256 requestId);
function claimWithdraw(uint256 requestId) external;

// --- è‡ªåŠ¨åŒ–æ¥å£ï¼ˆpermissionlessï¼‰ ---
function cycle() external;  // æ ¸å¿ƒï¼šä»»ä½•äººå¯è°ƒç”¨

// --- åªè¯»æ¥å£ï¼ˆç»™å‰ç«¯/è¯„å§”ï¼‰ ---
function quoteState() external view returns (
    uint256 totalAssets,
    uint256 alpValue,
    uint256 lpValue,
    uint256 hedgeValue,
    int256  netDelta,
    Regime  regime,
    uint256 nextCycleAt
);
function previewDeposit(uint256 assets) external view returns (uint256 shares);
function previewRedeem(uint256 shares) external view returns (uint256 assets);

// --- äº‹ä»¶ ---
event CycleExecuted(
    address indexed caller,
    Regime regime,
    int256 netDeltaBefore,
    int256 netDeltaAfter,
    uint256 bounty,
    uint256 timestamp
);
event RegimeSwitched(Regime oldRegime, Regime newRegime, uint256 volatilityBps);
event DepositMade(address indexed user, uint256 assets, uint256 shares);
event WithdrawRequested(address indexed user, uint256 requestId, uint256 shares);
event WithdrawClaimed(address indexed user, uint256 requestId, uint256 assets);
```

## 5.2 VolatilityOracleï¼ˆé“¾ä¸Šæ³¢åŠ¨ç‡è®¡ç®—å™¨ï¼‰

### è®¾è®¡æ€è·¯

ä¸ä¾èµ– Chainlinkï¼Œçº¯é“¾ä¸Šè®¡ç®—ã€‚åˆ©ç”¨ PancakeSwap V2 Pair çš„ price0CumulativeLast
åš TWAPï¼Œå†ç®—å·²å®ç°æ³¢åŠ¨ç‡ã€‚

ã€OpenCode æ”¹åŠ¨ã€‘å°† spot price æ”¹ä¸ºç´¯è®¡ä»· TWAPï¼Œç†ç”±: Pancake V2 Pair æš´éœ² price0CumulativeLast/price1CumulativeLastï¼ŒæŒ‰ UniswapV2OracleLibrary çš„ currentCumulativePrices æ–¹å¼å¯æ˜¾è‘—é™ä½æ“çºµé£é™©ã€‚

```solidity
contract VolatilityOracle {
    // ç”¨ç¯å½¢ç¼“å†²åŒºå­˜å‚¨ä»·æ ¼å¿«ç…§
    struct PriceSnapshot {
        uint256 timestamp;
        uint256 priceCumulative; // price0Cumulative æˆ– price1Cumulative (UQ112x112)
    }
    
    uint8 constant WINDOW_SIZE = 24;  // 24ä¸ªå¿«ç…§
    PriceSnapshot[24] public snapshots;
    uint8 public snapshotIndex;
    
    address public immutable pair;       // BTCB/USDT V2 Pair
    bool public immutable baseIsToken0;  // éƒ¨ç½²æ—¶å†™æ­»ï¼Œé¿å…ä»·æ ¼åå‘
    
    // === æ ¸å¿ƒæ–¹æ³• ===
    
    // è®°å½•ä»·æ ¼å¿«ç…§ï¼ˆcycle() å†…è°ƒç”¨ï¼Œæ— éœ€å•ç‹¬è§¦å‘ï¼‰
    function recordSnapshot() external {
        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =
            PancakeOracleLibrary.currentCumulativePrices(pair);
        uint priceCumulative = baseIsToken0 ? price0Cumulative : price1Cumulative;
        snapshots[snapshotIndex] = PriceSnapshot(blockTimestamp, priceCumulative);
        snapshotIndex = (snapshotIndex + 1) % WINDOW_SIZE;
    }
    
    // è®¡ç®— TWAP ä»·æ ¼ï¼ˆ1e18ï¼‰
    function _twapPrice1e18(PriceSnapshot memory prev, PriceSnapshot memory curr)
        internal pure returns (uint256 price1e18)
    {
        uint256 timeElapsed = curr.timestamp - prev.timestamp;
        uint256 priceAverage = (curr.priceCumulative - prev.priceCumulative) / timeElapsed;
        // priceAverage ä¸º UQ112x112ï¼Œè½¬æˆ 1e18
        price1e18 = (priceAverage * 1e18) / (2**112);
    }
    
    // è®¡ç®—å·²å®ç°æ³¢åŠ¨ç‡ï¼ˆbpsï¼‰
    // ä½¿ç”¨ log-return æ ‡å‡†å·®çš„ç®€åŒ–ç‰ˆæœ¬
    function getVolatilityBps() external view returns (uint256) {
        uint256 sumSquaredReturns = 0;
        uint256 count = 0;
        uint256 prevPrice = 0;
        
        for (uint8 i = 1; i < WINDOW_SIZE; i++) {
            uint8 curr = (snapshotIndex + WINDOW_SIZE - i) % WINDOW_SIZE;
            uint8 prev = (snapshotIndex + WINDOW_SIZE - i - 1) % WINDOW_SIZE;
            
            if (snapshots[curr].timestamp == 0 || snapshots[prev].timestamp == 0) continue;
            
            uint256 price = _twapPrice1e18(snapshots[prev], snapshots[curr]);
            if (prevPrice == 0) {
                prevPrice = price;
                continue;
            }
            
            int256 returnBps = int256((price * 10000) / prevPrice) - 10000;
            sumSquaredReturns += uint256(returnBps * returnBps);
            count++;
            prevPrice = price;
        }
        
        if (count == 0) return 0;
        return MathLib.sqrt(sumSquaredReturns / count);
    }
    
    // ç¡®å®š Regime
    function getRegime() external view returns (Regime) {
        uint256 vol = this.getVolatilityBps();
        if (vol < 100)  return Regime.CALM;    // < 1% æ³¢åŠ¨
        if (vol < 300)  return Regime.NORMAL;  // 1-3% æ³¢åŠ¨
        return Regime.STORM;                   // > 3% æ³¢åŠ¨
    }
}
```

ã€OpenCode æ”¹åŠ¨ã€‘baseIsToken0 åœ¨éƒ¨ç½²æ—¶é€šè¿‡ `IPancakePairV2(pair).token0()` æ ¡éªŒï¼Œç†ç”±: é¿å… BTCB/USDT åå‘å¯¼è‡´ TWAP ä»·æ ¼å€’ç½®ã€‚

### Regime åˆ‡æ¢é˜ˆå€¼ä¸é…æ¯”

```
Regime      | è§¦å‘æ¡ä»¶      | ALPé…æ¯” | LPé…æ¯” | Buffer | ç­–ç•¥é€»è¾‘
------------|--------------|---------|--------|--------|---------------------------
CALM        | vol < 1%     | 40%     | 57%    | 3%     | ä½æ³¢åŠ¨=LPå®‰å…¨ï¼Œå¤šé…LPèµšæ‰‹ç»­è´¹
NORMAL      | 1% <= vol<3% | 60%     | 37%    | 3%     | å¹³è¡¡é…æ¯”
STORM       | vol >= 3%    | 80%     | 17%    | 3%     | é«˜æ³¢åŠ¨=å¤šé…ALP(å¯¹å†²+æ”¶å…¥å¢åŠ )
```

**å…³é”®**: STORM æ¨¡å¼ä¸‹ ALP é…æ¯”å‡è‡³ 80%ï¼Œå› ä¸º:
1. LP çš„ IL åœ¨é«˜æ³¢åŠ¨æ—¶æ€¥å‰§å¢åŠ 
2. ALP çš„æ‰‹ç»­è´¹+æ¸…ç®—æ”¶å…¥åœ¨é«˜æ³¢åŠ¨æ—¶æš´å¢
3. ALP å……å½“æ³¢åŠ¨ç‡å¯¹å†²çš„è§’è‰²

## 5.3 Aster1001xAdapterï¼ˆå¯¹å†²é€‚é…å™¨ï¼‰

### æ¥å£ï¼ˆåŸºäº Louper éªŒè¯çš„ Diamond ABIï¼‰

ã€OpenCode æ”¹åŠ¨ã€‘å¤–éƒ¨å…¬å¼€æ–‡æ¡£æœªæ£€ç´¢åˆ°å®Œæ•´ ABIï¼›éœ€åœ¨ BSC ä¸Šç”¨ Louper å¯¼å‡ºå¹¶é€å­—æ®µæ¯”å¯¹ç²¾åº¦ã€‚ç†ç”±: å‚æ•°ç²¾åº¦é”™ä¸€ä½ä¼šå¯¼è‡´å¼€ä»“å¤±è´¥æˆ–èµ„é‡‘è¯¯å·®ã€‚

```solidity
library Aster1001xAdapter {
    // --- Diamond åœ°å€ ---
    address constant DIAMOND = 0x1b6f2d3844c6ae7d56ceb3c3643b9060ba28feb0;

    // --- OpenDataInput ç»“æ„ä½“ï¼ˆé“¾ä¸Š Louper éªŒè¯ç²¾åº¦ï¼‰ ---
    struct OpenDataInput {
        address pairBase;   // BTCB åœ°å€
        bool    isLong;     // false = shortï¼ˆå¯¹å†²ç”¨ï¼‰
        address tokenIn;    // USDT
        uint96  amountIn;   // ä¿è¯é‡‘, ç²¾åº¦ 1e18
        uint80  qty;        // åˆçº¦æ•°é‡, ç²¾åº¦ 1e10
        uint64  price;      // æœ€å·®å¯æ¥å—ä»·æ ¼, ç²¾åº¦ 1e8
        uint64  stopLoss;   // 0 (P0ä¸è®¾)
        uint64  takeProfit; // 0 (P0ä¸è®¾)
        uint24  broker;     // 0
    }
    
    // --- å†™æ“ä½œï¼ˆTradingPortalFacetï¼‰ ---
    function openShort(
        address diamond,
        address pairBase,
        address tokenIn,
        uint256 marginAmount,
        uint256 qty,
        uint256 worstPrice
    ) internal {
        OpenDataInput memory data = OpenDataInput({
            pairBase: pairBase,
            isLong: false,
            tokenIn: tokenIn,
            amountIn: marginAmount,
            qty: qty,
            price: worstPrice,
            stopLoss: 0,
            takeProfit: 0,
            broker: 0
        });
        
        IERC20(tokenIn).approve(diamond, marginAmount);
        IAsterDiamond(diamond).openMarketTrade(data);
    }
    
    function closeTrade(address diamond, bytes32 tradeHash) internal {
        IAsterDiamond(diamond).closeTrade(tradeHash);
    }
    
    function addMargin(address diamond, bytes32 tradeHash, uint96 amount) internal {
        IAsterDiamond(diamond).addMargin(tradeHash, amount);
    }
    
    // --- è¯»æ“ä½œï¼ˆTradingReaderFacetï¼‰ ---
    function getPositions(address diamond, address account, address pairBase) 
        internal view returns (bytes32[] memory tradeHashes, uint256 totalQty) 
    {
        // é€šè¿‡ getPositionsV2(account, pairBase) è·å–å½“å‰ä»“ä½
        // è¿”å› tradeHash åˆ—è¡¨å’Œæ€» qty
    }
    
    function getHedgeBaseQty(address diamond, address account, address pairBase)
        internal view returns (uint256 baseQty)
    {
        // ä»ä»“ä½æ•°æ®ä¸­æå– base æ•°é‡
        // ç”¨äºè®¡ç®— netDelta
    }
    
    // --- ç²¾åº¦è½¬æ¢ ---
    function usdToQty(uint256 usdAmount, uint256 price1e8) 
        internal pure returns (uint256 qty1e10)
    {
        // qty = usdAmount / price
        // usdAmount: 1e18, price: 1e8, qty: 1e10
        qty1e10 = (usdAmount * 1e10) / (price1e8 * 1e18 / 1e8);
    }
}
```

## 5.4 AsterAlpAdapterï¼ˆALP æ”¶ç›Šé€‚é…å™¨ï¼‰

```solidity
library AsterAlpAdapter {
    // --- æ ¸å¿ƒæ“ä½œï¼ˆAlpManagerFacetï¼‰ ---
    
    function mintAlp(address diamond, address tokenIn, uint256 amount, uint256 minAlp, bool stake) 
        internal returns (uint256 alpReceived)
    {
        IERC20(tokenIn).approve(diamond, amount);
        // minAlp ç”¨ 90% é¢„ä¼°å€¼åšæ»‘ç‚¹ä¿æŠ¤
        alpReceived = IAsterDiamond(diamond).mintAlp(tokenIn, amount, minAlp, stake);
    }
    
    function burnAlp(address diamond, address tokenOut, uint256 alpAmount, uint256 minOut)
        internal returns (uint256 tokenReceived)
    {
        // æ£€æŸ¥å†·å´æœŸ
        require(canBurn(diamond), "ALP: cooling period");
        tokenReceived = IAsterDiamond(diamond).burnAlp(tokenOut, alpAmount, minOut, address(this));
    }
    
    // --- åªè¯» ---
    
    function getAlpBalance(address diamond, address account)
        internal view returns (uint256)
    {
        address alpToken = IAsterDiamond(diamond).ALP();
        return IERC20(alpToken).balanceOf(account);
    }
    
    function canBurn(address diamond) internal view returns (bool) {
        uint256 cooldown = IAsterDiamond(diamond).coolingDuration();
        uint256 lastMint = IAsterDiamond(diamond).lastMintedTimestamp(address(this));
        return block.timestamp >= lastMint + cooldown;
    }
    
    function getAlpNAV(address diamond) internal view returns (uint256) {
        return IAsterDiamond(diamond).alpPrice();
    }
    
    function getAlpValueInUsd(address diamond, address account)
        internal view returns (uint256)
    {
        uint256 balance = getAlpBalance(diamond, account);
        uint256 nav = getAlpNAV(diamond);
        return (balance * nav) / 1e18;
    }
}
```

## 5.5 PancakeV2Adapter

```solidity
library PancakeV2Adapter {
    address constant ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address constant FACTORY = 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;
    
    function addLiquidity(
        address tokenA, address tokenB,
        uint256 amountA, uint256 amountB,
        uint256 slippageBps  // e.g. 50 = 0.5%
    ) internal returns (uint256 liquidity) {
        IERC20(tokenA).approve(ROUTER, amountA);
        IERC20(tokenB).approve(ROUTER, amountB);
        
        uint256 minA = amountA * (10000 - slippageBps) / 10000;
        uint256 minB = amountB * (10000 - slippageBps) / 10000;
        
        (, , liquidity) = IPancakeRouterV2(ROUTER).addLiquidity(
            tokenA, tokenB,
            amountA, amountB,
            minA, minB,
            address(this),
            block.timestamp + 300  // 5åˆ†é’Ÿ deadline
        );
    }
    
    function removeLiquidity(
        address tokenA, address tokenB,
        uint256 liquidity,
        uint256 slippageBps
    ) internal returns (uint256 amountA, uint256 amountB) {
        address pair = IPancakeFactoryV2(FACTORY).getPair(tokenA, tokenB);
        IERC20(pair).approve(ROUTER, liquidity);
        
        (amountA, amountB) = IPancakeRouterV2(ROUTER).removeLiquidity(
            tokenA, tokenB,
            liquidity,
            0, 0,  // ç”± slippage check åœ¨å¤–å±‚å¤„ç†
            address(this),
            block.timestamp + 300
        );
    }
    
    // V2 LP ä»½é¢è®¡ç®—ï¼ˆç¡®å®šæ€§ï¼‰
    function getUnderlyingAmounts(address pair, address account)
        internal view returns (uint256 amt0, uint256 amt1)
    {
        uint256 lpBal = IERC20(pair).balanceOf(account);
        (uint112 r0, uint112 r1, ) = IPancakePairV2(pair).getReserves();
        uint256 ts = IPancakePairV2(pair).totalSupply();
        
        amt0 = (lpBal * uint256(r0)) / ts;
        amt1 = (lpBal * uint256(r1)) / ts;
    }
    
    function getSpotPrice(address pair) internal view returns (uint256 price1e18) {
        (uint112 r0, uint112 r1, ) = IPancakePairV2(pair).getReserves();
        // price = r1/r0 (å‡è®¾ token0=BTCB, token1=USDT)
        price1e18 = (uint256(r1) * 1e18) / uint256(r0);
    }
}
```

## 5.6 FlashRebalancerï¼ˆFlash Loan åŸå­å†å¹³è¡¡ï¼‰

è¿™æ˜¯å›ç­”é¢˜ç›® "Volatility" Design Prompt çš„å…³é”®ç»„ä»¶ã€‚

### è®¾è®¡æ€è·¯

PancakeSwap V2 æ”¯æŒ Flash Swapï¼ˆç±»ä¼¼ Uniswap V2 Flash Loanï¼‰ï¼š
å¯ä»¥å…ˆå€Ÿå‡º tokenï¼Œåœ¨åŒä¸€ç¬”äº¤æ˜“å†…å½’è¿˜ï¼ˆåŠ æ‰‹ç»­è´¹ï¼‰ã€‚

```
Flash Rebalance åŸå­æµç¨‹ï¼ˆå•ç¬”äº¤æ˜“å†…å®Œæˆï¼‰:

  1. Flash Swap å€Ÿå‡º BTCB
         |
  2. removeLiquidityï¼ˆæ—§ LPï¼‰
         |
  3. æŒ‰æ–° regime æ¯”ä¾‹é‡æ–°è®¡ç®—é…æ¯”
         |
  4. addLiquidityï¼ˆæ–°æ¯”ä¾‹ï¼‰
         |
  5. è°ƒæ•´ 1001x å¯¹å†²ä»“ä½
         |
  6. å½’è¿˜ Flash Swapï¼ˆUSDT ç­‰ä»· + feeï¼ŒæŒ‰ Pair å…¬å¼è®¡ç®—ï¼‰
         |
  å…¨ç¨‹é›¶ä¸´æ—¶æ•å£ï¼(No Temporary Exposure)
```

### ä¸ºä»€ä¹ˆç”¨ Flash Swap è€Œä¸æ˜¯ Flash Loan?

```
+---------------------+------------------+-------------------+
| ç‰¹æ€§                | Flash Loan(Aave) | Flash Swap(V2)    |
+---------------------+------------------+-------------------+
| å¯ç”¨æ€§(BSC)         | éœ€ Aave éƒ¨ç½²     | PancakeSwap åŸç”Ÿ  |
| æ‰‹ç»­è´¹              | 0.05%            | 0.20%~0.25%*      |
| æ— é¢å¤–ä¾èµ–          | éœ€ Aave åˆçº¦     | å·²æœ‰ V2 Pair      |
| åŸå­æ€§              | æ˜¯               | æ˜¯                |
| å¯å€Ÿèµ„äº§            | Aave æ”¯æŒåˆ—è¡¨    | Pair ä¸­ä»»æ„ token |
+---------------------+------------------+-------------------+
```

*æ³¨: PancakePair.sol ä½¿ç”¨ `balanceAdjusted = balance*1000 - amountIn*2`ï¼Œå¯¹åº” 0.20% feeï¼›éƒ¨åˆ†èµ„æ–™æåˆ° 0.25%ï¼Œéœ€ä»¥é“¾ä¸Šå·²éªŒè¯åˆçº¦ä¸ºå‡†ã€‚

é€‰æ‹© Flash Swap: è™½ç„¶æ‰‹ç»­è´¹æ›´é«˜ï¼Œä½†**é›¶é¢å¤–ä¾èµ–**ï¼ˆæˆ‘ä»¬å·²ç»ç”¨äº† V2 Pairï¼‰ã€‚

ã€OpenCode æ”¹åŠ¨ã€‘å®ç°å‚è€ƒ `pancake-swap-periphery/ExampleFlashSwap.sol`ï¼Œå¿è¿˜é‡‘é¢ç”¨ `PancakeLibrary.getAmountsIn` è®¡ç®—ã€‚ç†ç”±: fee ä»¥åˆçº¦ä¸ºå‡†ä¸”é¿å…ç¡¬ç¼–ç è¯¯å·®ã€‚

```solidity
contract FlashRebalancer {
    // PancakeSwap V2 Flash Swap å›è°ƒ
    // å½“ Pair è°ƒç”¨æ­¤å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬å·²ç»æ”¶åˆ°äº†å€Ÿå‡ºçš„ token
    function pancakeCall(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external {
        // éªŒè¯: åªæ¥å—æ¥è‡ªå·²çŸ¥ Pair çš„å›è°ƒ
        address token0 = IPancakePairV2(pair).token0();
        address token1 = IPancakePairV2(pair).token1();
        require(msg.sender == PancakeLibrary.pairFor(factory, token0, token1), "Invalid caller");
        require(sender == address(vault), "Invalid sender");
        
        // è§£ç æ“ä½œå‚æ•°
        (RebalanceParams memory params) = abi.decode(data, (RebalanceParams));
        
        // Step 1: ç§»é™¤æ—§ LP
        uint256 oldLiquidity = IERC20(pair).balanceOf(address(vault));
        PancakeV2Adapter.removeLiquidity(...);
        
        // Step 2: æŒ‰æ–° regime è®¡ç®—ç›®æ ‡é…æ¯”
        (uint256 targetAlpBps, uint256 targetLpBps) = _getTargetAlloc(params.regime);
        
        // Step 3: é‡æ–°éƒ¨ç½²èµ„äº§
        // ... addLiquidity with new ratio ...
        
        // Step 4: è°ƒæ•´å¯¹å†²
        // ... openMarketTrade or closeTrade ...
        
        // Step 5: è®¡ç®—åº”å½’è¿˜é‡‘é¢ï¼ˆä»¥ Pair å…¬å¼ä¸ºå‡†ï¼‰
        address[] memory path = new address[](2);
        path[0] = token0;
        path[1] = token1;
        // è‹¥å€Ÿçš„æ˜¯ token1ï¼Œåˆ™ path åè½¬å¹¶æ”¹ç”¨ amount1
        uint256 repayAmount = PancakeLibrary.getAmountsIn(factory, amount0, path)[0];
        IERC20(token0).transfer(msg.sender, repayAmount);
    }
    
    // è§¦å‘ Flash Rebalance
    function executeFlashRebalance(RebalanceParams calldata params) external {
        // è®¡ç®—éœ€è¦å€Ÿå¤šå°‘
        uint256 borrowAmount = _calcBorrowNeeded(params);
        
        // å‘èµ· Flash Swap
        IPancakePairV2(pair).swap(
            borrowAmount, 0,  // å€Ÿ token0 (BTCB)
            address(this),
            abi.encode(params)  // data éç©º = flash swap
        );
    }
}
```

### Flash Rebalance çš„ä¸‰å¤§ä¼˜åŠ¿

1. **é›¶ä¸´æ—¶æ•å£**: ä¸éœ€è¦å…ˆå–å†ä¹°ï¼Œé¿å…ä¸¤ç¬”äº¤æ˜“é—´çš„ä»·æ ¼å˜åŠ¨
2. **åŸå­æ€§**: ä»»ä½•ä¸€æ­¥å¤±è´¥ = æ•´ç¬”äº¤æ˜“å›æ»šï¼Œèµ„é‡‘å®‰å…¨
3. **MEV æŠµæŠ—**: å•ç¬”äº¤æ˜“ï¼Œä¸‰æ˜æ²»æ”»å‡»çª—å£å¤§å¹…ç¼©å°

## 5.7 WithdrawalQueueï¼ˆæ— ç®¡ç†å‘˜èµå›é˜Ÿåˆ—ï¼‰

```solidity
contract WithdrawalQueue {
    struct Request {
        address receiver;
        uint256 shares;
        uint256 requestedAt;
        bool    claimed;
    }
    
    mapping(uint256 => Request) public requests;
    uint256 public nextRequestId;
    
    // --- å‘èµ·èµå›è¯·æ±‚ ---
    function requestWithdraw(uint256 shares, address receiver) 
        external returns (uint256 requestId) 
    {
        // é”å®š sharesï¼ˆä»ç”¨æˆ·è½¬å…¥ queue åˆçº¦ï¼‰
        vault.transferFrom(msg.sender, address(this), shares);
        
        requestId = nextRequestId++;
        requests[requestId] = Request({
            receiver: receiver,
            shares: shares,
            requestedAt: block.timestamp,
            claimed: false
        });
        
        emit WithdrawRequested(msg.sender, requestId, shares);
    }
    
    // --- æ‰§è¡Œèµå›ï¼ˆpermissionlessï¼Œä»»ä½•äººå¯è°ƒç”¨ï¼‰ ---
    function claimWithdraw(uint256 requestId) external {
        Request storage req = requests[requestId];
        require(!req.claimed, "Already claimed");
        require(req.shares > 0, "Invalid request");
        
        // è®¡ç®—åº”å¾— USDT
        uint256 assetsOwed = vault.previewRedeem(req.shares);
        
        // å°è¯•æ»¡è¶³èµå›
        uint256 available = _getAvailableForWithdraw();
        
        if (available >= assetsOwed) {
            // æƒ…å†µ1: æœ‰è¶³å¤ŸæµåŠ¨æ€§ -> ç›´æ¥èµå›
            req.claimed = true;
            vault.redeem(req.shares, req.receiver, address(this));
        } else {
            // æƒ…å†µ2: æµåŠ¨æ€§ä¸è¶³ -> å°è¯•é‡Šæ”¾èµ„é‡‘
            //   a) å…ˆå¹³æ‰ 1001x å¯¹å†²ä»“ä½ï¼ˆé‡Šæ”¾ä¿è¯é‡‘+PnLï¼‰
            //   b) å†ç§»é™¤ LP
            //   c) è‹¥ ALP å¯ burn ä¸”æœªè¶… burn cap -> burn ALP
            //   d) è‹¥ä»ä¸è¶³ -> ä¿æŒ pending
            
            _attemptLiquidation(assetsOwed - available);
            
            available = _getAvailableForWithdraw();
            if (available >= assetsOwed) {
                req.claimed = true;
                vault.redeem(req.shares, req.receiver, address(this));
            }
            // å¦åˆ™ä¿æŒ pendingï¼Œç­‰ä¸‹æ¬¡ cycle() æˆ–å†·å´ç»“æŸåå† claim
        }
    }
    
    // é‡Šæ”¾èµ„é‡‘çš„ä¼˜å…ˆçº§ï¼ˆé‡è¦ï¼ï¼‰
    function _attemptLiquidation(uint256 deficit) internal {
        // ä¼˜å…ˆçº§ 1: ç”¨ cashBuffer ä¸­çš„ USDT
        // ä¼˜å…ˆçº§ 2: å¹³æ‰ 1001x ä»“ä½ï¼ˆé‡Šæ”¾ä¿è¯é‡‘ï¼‰
        // ä¼˜å…ˆçº§ 3: ç§»é™¤ V2 LP
        // ä¼˜å…ˆçº§ 4: burn ALPï¼ˆå¦‚æœå†·å´æœŸå·²è¿‡ + æœªè¶… burn capï¼‰
        //
        // æ³¨æ„: å…ˆå¹³ 1001x å† burn ALP
        // å› ä¸º burn cap å…¬å¼ä¸­ "Value of user's positions" å½±å“ä¸Šé™
        // å¹³ä»“å burn cap æ›´é«˜ -> èƒ½ burn æ›´å¤š ALP
    }
}
```


---

<a id="part6"></a>
# ç¬¬å…­éƒ¨åˆ†ï¼šæ ¸å¿ƒç®—æ³•

## 6.1 åŠ¨æ€èµ„äº§é…ç½®ï¼ˆæ³¢åŠ¨ç‡è‡ªé€‚åº”ï¼‰

è¿™æ˜¯åŒºåˆ«äºæŠ€æœ¯æ–‡æ¡£1ï¼ˆå›ºå®š 80/20ï¼‰çš„æ ¸å¿ƒæ”¹è¿›ã€‚

```
é…æ¯”å†³ç­–æµç¨‹:

  1. VolatilityOracle.getVolatilityBps()
         |
         v
  2. ç¡®å®š Regime (CALM / NORMAL / STORM)
         |
         v
  3. æŸ¥è¡¨è·å–ç›®æ ‡é…æ¯”
         |
  +------+------+------+
  |      |      |      |
  v      v      v      v
 CALM   NORMAL STORM  (é…æ¯”)
 40/57  60/37  80/17  (ALP/LP)
         |
         v
  4. è®¡ç®—å½“å‰å®é™…é…æ¯”
         |
         v
  5. åå·®è¶…è¿‡ rebalance threshold?
     |           |
     No          Yes
     |           |
     v           v
   è·³è¿‡      æ‰§è¡Œå†å¹³è¡¡
             (Flash Rebalance
              æˆ–æ™®é€šå†å¹³è¡¡)
```

### é…æ¯”è®¡ç®—ï¼ˆä¼ªä»£ç ï¼‰

```solidity
function _computeTargetAllocation() internal view returns (
    uint256 targetAlpBps, uint256 targetLpBps, uint256 targetBufferBps
) {
    Regime regime = volatilityOracle.getRegime();
    
    if (regime == Regime.CALM) {
        targetAlpBps = calmAlpBps;    // 4000
        targetLpBps  = calmLpBps;     // 5700
    } else if (regime == Regime.NORMAL) {
        targetAlpBps = normalAlpBps;  // 6000
        targetLpBps  = normalLpBps;   // 3700
    } else { // STORM
        targetAlpBps = stormAlpBps;   // 8000
        targetLpBps  = stormLpBps;    // 1700
    }
    
    targetBufferBps = 10000 - targetAlpBps - targetLpBps;  // å§‹ç»ˆ 300
}
```

## 6.2 Delta å¯¹å†²ç®—æ³•

ä¿ç•™æŠ€æœ¯æ–‡æ¡£1çš„æ ¸å¿ƒè®¾è®¡ï¼Œå¢åŠ ç²¾åº¦å¤„ç†å’Œå®‰å…¨æ£€æŸ¥ã€‚

```
Delta å¯¹å†²é€»è¾‘:

  LP ä¸­çš„ BTCB æ•°é‡ = amtBase
  1001x short ç­‰ä»· BTCB = hedgeBaseQty

  netDelta = amtBase - hedgeBaseQty
  deltaBand = amtBase * deltaBandBps / 10000

  if abs(netDelta) <= deltaBand:
      -> ä¸éœ€è¦è°ƒæ•´ï¼ˆåœ¨å…è®¸èŒƒå›´å†…ï¼‰
  
  elif netDelta > 0:
      -> LP ä¸­ BTCB å¤šäºå¯¹å†²é‡
      -> éœ€è¦åŠ å¤§ short: openMarketTrade(isLong=false)
      -> æ–°å¢ short æ•°é‡ = netDelta å¯¹åº”çš„ qty
  
  elif netDelta < 0:
      -> å¯¹å†²è¿‡åº¦
      -> éœ€è¦å‡å° short: closeTrade(éƒ¨åˆ†æˆ–å…¨éƒ¨)
      -> å‡ä»“æ•°é‡ = |netDelta| å¯¹åº”çš„ qty
```

### amtBase è®¡ç®—ï¼ˆV2 LP ä»½é¢æ‹†è§£ï¼‰

```solidity
function _getLpBaseAmount() internal view returns (uint256 amtBase) {
    uint256 lpBal = IERC20(v2Pair).balanceOf(address(this));
    (uint112 r0, uint112 r1, ) = IPancakePairV2(v2Pair).getReserves();
    uint256 ts = IPancakePairV2(v2Pair).totalSupply();
    
    // å‡è®¾ token0 = BTCB (éœ€åœ¨éƒ¨ç½²æ—¶ç¡®è®¤)
    amtBase = (lpBal * uint256(r0)) / ts;
}
```

### qty ç²¾åº¦è½¬æ¢

```solidity
// 1001x ç²¾åº¦: USDT 1e18, price 1e8, qty 1e10
function _baseToQty(uint256 baseAmount, uint256 price1e8) 
    internal pure returns (uint256 qty1e10) 
{
    // baseAmount: å®é™… BTCB æ•°é‡ (1e18)
    // price: BTCB/USDT (1e8)
    // qty: åˆçº¦æ•°é‡ (1e10)
    // 
    // notional = baseAmount * price / 1e8 (å¾—åˆ° USDT 1e18)
    // qty = notional è½¬æ¢ä¸º 1e10 ç²¾åº¦ï¼ˆéœ€è¦è¯»å– PairView è·å–æ¢ç®—ç³»æ•°ï¼‰
    //
    // å¤‡é€‰æ–¹æ¡ˆï¼ˆP0ï¼‰: ç›´æ¥ç”¨ä»“ä½è¯»å–åšé—­ç¯æ§åˆ¶
    // å³: è¯»å–å½“å‰ short çš„ baseQtyï¼Œä¸ amtBase æ¯”è¾ƒ
    // å¢é‡å¼€ä»“ç›´åˆ° delta å›åˆ° band
}
```

## 6.3 Flash Loan åŸå­å†å¹³è¡¡ç®—æ³•

```
è§¦å‘æ¡ä»¶:
  actualAlpBps ä¸ targetAlpBps åå·® > 500 bps (5%)
  OR
  Regime å‘ç”Ÿåˆ‡æ¢

Flash Rebalance æ­¥éª¤ï¼ˆå•ç¬”äº¤æ˜“ï¼‰:

  Step 0: è¯»å–å½“å‰çŠ¶æ€
    - totalValue = alpValue + lpValue + hedgeValue + cashBuffer
    - currentRegime -> targetAlpBps, targetLpBps
    
  Step 1: è®¡ç®—æ¯å±‚åº”æœ‰å¤šå°‘ USDT ä»·å€¼
    - targetAlpValue  = totalValue * targetAlpBps / 10000
    - targetLpValue   = totalValue * targetLpBps  / 10000
    - targetCashValue = totalValue * cashBufferBps / 10000
    
  Step 2: è®¡ç®—å·®é¢
    - alpDelta = targetAlpValue - currentAlpValue
    - lpDelta  = targetLpValue  - currentLpValue
    
  Step 3: æ‰§è¡Œè°ƒæ•´
    IF alpDelta > 0 (éœ€è¦å¢åŠ  ALP):
      - è‹¥æœ‰å¤šä½™ USDT: mintAlp(å¤šä½™ USDT)
      - è‹¥éœ€ä» LP æ’¤å‡º: removeLiquidity -> mintAlp
      
    IF alpDelta < 0 (éœ€è¦å‡å°‘ ALP):
      - è‹¥ ALP å¯ burn: burnAlp -> å›åˆ° USDT æˆ– addLiquidity
      - è‹¥ ALP åœ¨å†·å´æœŸ: åªè°ƒæ•´ LP/cash æ¯”ä¾‹ï¼ŒALP æš‚ä¸åŠ¨
      
    IF lpDelta > 0 (éœ€è¦å¢åŠ  LP):
      - swap USDT -> BTCB (ä¸€åŠ)
      - addLiquidity(BTCB, USDT)
      
    IF lpDelta < 0 (éœ€è¦å‡å°‘ LP):
      - removeLiquidity
      - swap BTCB -> USDT (é‡Šæ”¾çš„ BTCB)
      
  Step 4: é‡æ–°å¯¹å†²
    - è®¡ç®—æ–°çš„ amtBase (LP ä¸­ BTCB)
    - è®¡ç®— netDelta
    - è°ƒæ•´ 1001x short ä»“ä½
    
  Step 5: éªŒè¯
    - assert: æ–°é…æ¯”åå·® < 200 bps
    - assert: netDelta åœ¨ band å†…
```

## 6.4 Bounty è®¡ç®—ï¼ˆåˆ©æ¶¦åˆ†æˆæ¨¡å‹ï¼‰

æŠ€æœ¯æ–‡æ¡£1 çš„ bounty è¿‡äºç®€å•ã€‚æ”¹ä¸º**åˆ©æ¶¦åˆ†æˆ + æœ€ä½ä¿éšœ**æ¨¡å‹ï¼š

```solidity
function _calculateBounty() internal view returns (uint256 bounty) {
    // æ–¹å¼1: cycle äº§ç”Ÿçš„åˆ©æ¶¦çš„ 10%
    uint256 profitSinceLastCycle = _estimateProfit();
    uint256 profitBounty = profitSinceLastCycle * 1000 / 10000; // 10%
    
    // æ–¹å¼2: æœ€ä½ä¿éšœï¼ˆé˜²æ­¢æ— åˆ©æ¶¦æ—¶æ— äººè°ƒç”¨ï¼‰
    // ä» cashBuffer ä¸­æ”¯ä»˜ï¼Œé‡‘é¢ = estimatedGasCost * 1.5
    uint256 gasPrice = tx.gasprice;
    uint256 estimatedGas = 500_000; // cycle() é¢„ä¼° gas
    uint256 gasCostUsd = gasPrice * estimatedGas * _getBnbPriceInUsdt() / 1e18;
    uint256 minBounty = gasCostUsd * 150 / 100; // 1.5x gas cost
    
    // å–ä¸¤è€…è¾ƒå¤§å€¼ï¼Œä½†ä¸è¶…è¿‡ maxBounty
    bounty = profitBounty > minBounty ? profitBounty : minBounty;
    
    uint256 maxBounty = totalDeployedValue * 50 / 10000; // æœ€å¤§ 0.5%
    if (bounty > maxBounty) bounty = maxBounty;
}
```

### OpenCode è¡¥å……ï¼šBounty å®‰å…¨æŠ¤æ ï¼ˆAnti-Gasprice Abuseï¼‰

é£é™©:
- tx.gasprice å¯è¢«è°ƒç”¨è€…æŠ¬é«˜ï¼Œå¯¼è‡´ bounty è¢«æ”¾å¤§
- cashBuffer å¯èƒ½è¢«æŠ½å¹²ï¼Œå½±å“èµå›ä¸é£æ§

ä¿®æ­£å»ºè®®:
1. gasPriceUsed = min(tx.gasprice, MAX_GAS_PRICE) æˆ–ä½¿ç”¨ block.basefee + tipCap
2. bounty å— cashBuffer ä¸Šé™çº¦æŸï¼ˆé˜²æ­¢æŠ½å¹²ï¼‰
3. cashBuffer ä¸è¶³æ—¶å…è®¸éƒ¨åˆ†æ”¯ä»˜ï¼Œä¸ revert

å‚è€ƒä¼ªä»£ç :
```solidity
uint256 gasPriceUsed = tx.gasprice;
if (gasPriceUsed > MAX_GAS_PRICE) gasPriceUsed = MAX_GAS_PRICE;

uint256 minBounty = gasPriceUsed * estimatedGas * _getBnbPriceInUsdt() / 1e18;
minBounty = minBounty * 150 / 100;

uint256 bufferCap = cashBuffer * 2000 / 10000; // 20%
bounty = profitBounty > minBounty ? profitBounty : minBounty;
bounty = bounty > maxBounty ? maxBounty : bounty;
bounty = bounty > bufferCap ? bufferCap : bounty;
```

---

<a id="part7"></a>
# ç¬¬ä¸ƒéƒ¨åˆ†ï¼šçŠ¶æ€æœºä¸èµ„é‡‘æµ

## 7.1 Deposit æµç¨‹

```
ç”¨æˆ·è°ƒç”¨ deposit(assets, receiver)
         |
         v
  1. æ”¶å– USDT
  2. è®¡ç®— shares (ERC-4626 æ ‡å‡†)
     shares = assets * totalSupply / totalAssets
     (é¦–æ¬¡ deposit: shares = assets)
  3. Mint vault shares ç»™ receiver
  4. å°† USDT å­˜å…¥ cashBuffer
         |
         v
  [ä¸ç«‹å³éƒ¨ç½²! ç­‰å¾… cycle() ç»Ÿä¸€éƒ¨ç½²]
  åŸå› :
  - é¿å…å°é¢ deposit é¢‘ç¹å¼€ä»“çš„æ‘©æ“¦ï¼ˆ1001x æ‰§è¡Œè´¹ $0.50ï¼‰
  - ALP mint fee æ˜¯åŠ¨æ€çš„ï¼Œbatch æ•ˆæœæ›´å¥½
  - cycle() ä¼šè¯»å–æœ€æ–° regime å†³å®šé…æ¯”
```

## 7.2 Cycle æµç¨‹ï¼ˆæ ¸å¿ƒè‡ªåŠ¨åŒ–å¾ªç¯ï¼‰

```
ä»»ä½•äººè°ƒç”¨ cycle()
         |
  ===== PHASE 0: å‰ç½®æ£€æŸ¥ =====
         |
  0a. require(block.timestamp >= lastCycleTimestamp + minCycleInterval)
  0b. æ£€æŸ¥ Aster diamond æ˜¯å¦ pausedï¼ˆè‹¥å¯è¯»ï¼‰
         |
  ===== PHASE 1: è¯»å–å…¨å±€çŠ¶æ€ =====
         |
  1a. vault USDT ä½™é¢
  1b. ALP ä½™é¢ + NAV -> ALP ä»·å€¼(USD)
  1c. LP ä½™é¢ -> getReserves -> amtBase, amtQuote
  1d. 1001x ä»“ä½ -> hedgeBaseQty, marginUsed, unrealizedPnL
  1e. BNB/USDT ä»·æ ¼ï¼ˆç”¨äº gas cost ä¼°ç®—ï¼‰
  1f. BTCB/USDT ä»·æ ¼ï¼ˆç”¨äº delta è®¡ç®—ï¼‰
         |
  ===== PHASE 2: æ³¢åŠ¨ç‡ + Regime =====
         |
  2a. if (block.timestamp - lastSnapshotTs >= minSnapshotInterval):
        volatilityOracle.recordSnapshot()
  2b. if (snapshotCount < MIN_SAMPLES):
        newRegime = Regime.NORMAL   // å†·å¯åŠ¨é»˜è®¤
      else:
        newRegime = volatilityOracle.getRegime()
  2c. if (newRegime != currentRegime):
        emit RegimeSwitched(currentRegime, newRegime, vol)
        currentRegime = newRegime
         |
  ===== PHASE 3: è®¡ç®—ç›®æ ‡é…æ¯” =====
         |
  3a. (targetAlpBps, targetLpBps) = _computeTargetAllocation()
  3b. totalValue = alpValue + lpValue + hedgeValue + cashBalance
  3c. targetAlpValue = totalValue * targetAlpBps / 10000
  3d. targetLpValue = totalValue * targetLpBps / 10000
         |
  ===== PHASE 4: èµ„äº§å†å¹³è¡¡ =====
         |
  4a. IF regime åˆšåˆ‡æ¢ ä¸” åå·® > 500 bps:
        -> executeFlashRebalance() [åŸå­æ“ä½œ]
      ELSE:
        -> å¢é‡è°ƒæ•´:
           - å¤šä½™ USDT -> mintAlp æˆ– addLiquidity
           - ALP è¶…é… -> burnAlp (è‹¥å¯) æˆ–ç­‰å¾…
           - LP è¶…é… -> removeLiquidity
         |
  ===== PHASE 5: Delta å¯¹å†² =====
         |
  5a. amtBase = _getLpBaseAmount()
  5b. hedgeBaseQty = Aster1001xAdapter.getHedgeBaseQty()
  5c. netDelta = amtBase - hedgeBaseQty
  5d. IF abs(netDelta) > amtBase * deltaBandBps / 10000:
        IF netDelta > 0: openShort(delta_amount)
        IF netDelta < 0: reduceShort(|delta_amount|)
         |
  ===== PHASE 6: Bounty + è®°å½• =====
         |
  6a. bounty = _calculateBounty()
  6b. USDT.transfer(msg.sender, bounty)
  6c. lastCycleTimestamp = block.timestamp
  6d. emit CycleExecuted(...)
```

è¡¥å……è¯´æ˜:
- å†·å¯åŠ¨é˜¶æ®µ (snapshotCount < MIN_SAMPLES) å¼ºåˆ¶ NORMALï¼Œé¿å…è¯¯è§¦å‘ STORM
- snapshot é‡‡æ ·å¿…é¡»æ»¡è¶³æœ€å°é—´éš” (minSnapshotInterval)ï¼Œå¦åˆ™ TWAP å¤±çœŸ
- å†·å¯åŠ¨æ—¶ä¸è§¦å‘ Flash Rebalance

## 7.3 Withdraw æµç¨‹

```
=== å¿«é€Ÿè·¯å¾„ï¼ˆcashBuffer å……è¶³ï¼‰ ===

ç”¨æˆ·è°ƒç”¨ redeem(shares, receiver, owner)
  -> è®¡ç®— assets = shares * totalAssets / totalSupply
  -> IF cashBuffer >= assets:
       ç›´æ¥è½¬ USDT ç»™ receiver
       Burn vault shares

=== æ…¢é€Ÿè·¯å¾„ï¼ˆéœ€è¦é‡Šæ”¾èµ„é‡‘ï¼‰ ===

ç”¨æˆ·è°ƒç”¨ requestWithdraw(shares)
  -> é”å®š shares
  -> ç”Ÿæˆ requestId
  -> ç­‰å¾…...

ä»»ä½•äººè°ƒç”¨ claimWithdraw(requestId)
  -> å°è¯•é‡Šæ”¾èµ„é‡‘:
     1. å…ˆå¹³ 1001x ä»“ä½ï¼ˆæé«˜ ALP burn capï¼‰
     2. ç§»é™¤ LP
     3. Burn ALPï¼ˆè‹¥å†·å´æœŸå·²è¿‡ï¼‰
     4. è‹¥ä»ä¸è¶³ -> ä¿æŒ pending
  -> æˆåŠŸ: è½¬ USDT ç»™ receiver

=== ALP 48h å†·å´æœŸå¤„ç† ===

åœºæ™¯: ç”¨æˆ·åœ¨ ALP mint å 48h å†…èµå›
  -> claimWithdraw ä¼š:
     a) å…ˆç”¨ cashBuffer + LP + 1001x margin æ»¡è¶³éƒ¨åˆ†
     b) ALP éƒ¨åˆ†æ ‡è®°ä¸º pending
     c) 48h åå†æ¬¡ claimWithdraw -> burn ALP -> å®Œæˆèµå›
  -> å…¨è¿‡ç¨‹æ— ç®¡ç†å‘˜ä»‹å…¥!
```

### OpenCode è¡¥å……ï¼šèµå›æ¿€åŠ±ä¸éƒ¨åˆ†é¢†å–ï¼ˆClaim Incentivesï¼‰

- claimWithdraw ç»™è°ƒç”¨è€…å°é¢ bountyï¼ˆæ¥æº cashBufferï¼‰

- æ”¯æŒ partial claimï¼Œè®°å½•å·²é¢†å–é‡‘é¢ï¼Œé¿å…é‡å¤è®¡ç®—

- èµ„é‡‘ä¸è¶³æ—¶å…è®¸éƒ¨åˆ†è½¬å‡ºï¼Œé™ä½æ’é˜Ÿå‹åŠ›

---

<a id="part8"></a>
# ç¬¬å…«éƒ¨åˆ†ï¼šå®‰å…¨æ¨¡å‹

## 8.1 æƒé™è®¾è®¡ï¼ˆé›¶ç®¡ç†å‘˜ï¼‰

```
å®‰å…¨ç¡¬çº¦æŸï¼ˆéªŒæ”¶å¿…è¿‡ï¼‰:

  [x] EngineVault æ—  owner / admin / onlyRole
  [x] æ—  upgradeTo (ä¸æ˜¯ proxy)
  [x] æ—  setParams (å‚æ•°å…¨éƒ¨ immutable)
  [x] æ—  sweep / emergencyWithdraw(adminç‰ˆ)
  [x] cycle() å®Œå…¨ permissionless
  [x] claimWithdraw() å®Œå…¨ permissionless
  [x] æ—  API key / agent private key
  [x] æ—  Chainlink keeper / Gelato ä¾èµ–
  [x] æ—  off-chain Merkle root / backend
```

## 8.2 MEV ä¿æŠ¤

```
æ”»å‡»å‘é‡                    | é˜²æŠ¤æªæ–½
----------------------------|------------------------------------------
ä¸‰æ˜æ²»æ”»å‡» (Sandwich)       | Flash Rebalance å•ç¬”äº¤æ˜“å†…å®Œæˆ
                            | addLiquidity è®¾ç½® amountMin (slippage)
                            | swap è®¾ç½® amountOutMin
                            | ALP mint/burn è®¾ç½® minOut + deadline
å‰ç«¯è¿è¡Œ (Frontrun)         | cycle() æœ‰ minCycleInterval é™åˆ¶
                            | bounty åŸºäºåˆ©æ¶¦ï¼Œfrontrun æ— é¢å¤–åˆ©æ¶¦
æŠ¢è·‘ deposit (Deposit MEV)  | share è®¡ç®—åŸºäº totalAssets()
                            | æ”»å‡»è€…éœ€è¦å…ˆæ¨é«˜ totalAssets å† deposit
                            | ä½† totalAssets æ¥è‡ªå¤–éƒ¨åè®® NAVï¼Œéš¾æ“æ§
ä»·æ ¼æ“çºµ                    | æ³¢åŠ¨ç‡ Oracle ç”¨å¤šå¿«ç…§ TWAP
                            | 1001x ä½¿ç”¨å…¶è‡ªèº« oracleï¼Œé Pancake spot
```

## 8.3 é£é™©åˆ†å±‚

```
+===========+==============================+===========================+
| é£é™©å±‚çº§  | é£é™©æè¿°                      | ç¼“è§£æªæ–½                  |
+===========+==============================+===========================+
| ç³»ç»Ÿæ€§    | Aster diamond è¢« pause       | æ£€æµ‹ pause çŠ¶æ€, revert   |
|           | BSC ç½‘ç»œæ‹¥å µ                  | deadline + gas estimation  |
+-----------+------------------------------+---------------------------+
| åè®®å±‚    | ALP NAV ä¸‹è·Œ(äº¤æ˜“è€…æ•´ä½“ç›ˆåˆ©) | Regime åˆ‡æ¢å‡å°‘ ALP é…æ¯”   |
|           | 1001x ä»“ä½è¢«æ¸…ç®—              | ä¿è¯é‡‘å……è¶³(>=10xæ æ†ç©ºé—´) |
|           | ALP burn cap é™åˆ¶èµå›         | WithdrawalQueue æ’é˜Ÿå¤„ç†  |
+-----------+------------------------------+---------------------------+
| ç»æµå±‚    | å¯¹å†²æˆæœ¬ > LP æ”¶ç›Š            | åŠ¨æ€é…æ¯”å‡å°‘ LP ä»“ä½       |
|           | èµ„é‡‘è´¹ç‡ä¸åˆ©                  | ç›‘æ§ funding, å¿…è¦æ—¶å¹³ä»“   |
|           | Gas è´¹é«˜äº bounty             | æœ€ä½ bounty = 1.5x gas   |
+-----------+------------------------------+---------------------------+
| æ“ä½œå±‚    | æ— äººè°ƒç”¨ cycle()              | bounty æ¿€åŠ± + å…¬å¼€ MEV bot |
|           | å¤§é¢èµå›æŒ¤å…‘                  | æ’é˜Ÿ + ä¼˜å…ˆçº§é‡Šæ”¾          |
+===========+==============================+===========================+
```

## 8.4 Circuit Breakerï¼ˆç´§æ€¥ç†”æ–­ï¼‰

è™½ç„¶æ— ç®¡ç†å‘˜ï¼Œä½†å¯ä»¥é€šè¿‡**ç¡®å®šæ€§è§„åˆ™**å®ç°è‡ªåŠ¨ç†”æ–­ã€‚
å»ºè®®é‡‡ç”¨ ONLY_UNWIND æ¨¡å¼ï¼Œé¿å… revert å¯¼è‡´èµ„é‡‘é”æ­»:

```solidity
enum RiskMode { NORMAL, ONLY_UNWIND }
RiskMode public riskMode;

// åœ¨ cycle() ä¸­çš„å®‰å…¨æ£€æŸ¥
function _circuitBreakerCheck() internal {
    bool triggered = false;

    // 1. ALP NAV æš´è·Œæ£€æµ‹
    uint256 currentNav = AsterAlpAdapter.getAlpNAV(asterDiamond);
    uint256 navDropBps = (lastKnownNav - currentNav) * 10000 / lastKnownNav;
    if (navDropBps > 1000) triggered = true;

    // 2. 1001x ä»“ä½å¥åº·åº¦
    // è‹¥ä¿è¯é‡‘ç‡æ¥è¿‘æ¸…ç®—çº¿ -> è‡ªåŠ¨å‡ä»“æˆ–å¹³ä»“

    // 3. ä»·æ ¼åå·®æ£€æµ‹
    uint256 oraclePrice = _get1001xPrice();
    uint256 spotPrice = PancakeV2Adapter.getSpotPrice(v2Pair);
    uint256 deviationBps = _absDiff(oraclePrice, spotPrice) * 10000 / oraclePrice;
    if (deviationBps > 500) triggered = true;

    if (triggered) riskMode = RiskMode.ONLY_UNWIND;
}

function _isAddPositionAllowed() internal view returns (bool) {
    return riskMode == RiskMode.NORMAL;
}
```

ONLY_UNWIND æ¨¡å¼ä¸‹:

- ç¦æ­¢: mintAlp / addLiquidity / å¢åŠ  short

- å…è®¸: burnAlp / removeLiquidity / reduceShort / æé«˜ cashBuffer

- è§£é™¤æ¡ä»¶: è¿ç»­ N æ¬¡ cycle() æ»¡è¶³ navDropBps < X ä¸” deviationBps < Y

---

<a id="part9"></a>
# ç¬¬ä¹éƒ¨åˆ†ï¼šç»æµæ¨¡å‹ä¸æ”¶ç›Šæ¨¡æ‹Ÿ

## 9.1 æ”¶ç›Šæ¥æºå…¨æ™¯

```
æ”¶ç›Šæ¥æº          | é¢„ä¼° APY | è¯´æ˜
------------------|----------|--------------------------------
ALP åšå¸‚ PnL      | 5-15%    | äº¤æ˜“è€…ç»Ÿè®¡äºæŸ = ALP ç›ˆåˆ©
ALP äº¤æ˜“æ‰‹ç»­è´¹    | 3-8%     | 0.08% * äº¤æ˜“é‡
ALP èµ„é‡‘è´¹ç‡      | 1-5%     | æ°¸ç»­åˆçº¦ funding
ALP æ¸…ç®—æ”¶ç›Š      | 1-3%     | çˆ†ä»“ä¿è¯é‡‘å½’å…¥æ± 
V2 LP äº¤æ˜“è´¹      | 5-20%    | 0.17% * äº¤æ˜“é‡ (BTCB/USDT)
                  |          | *æ€»è´¹ç‡ 0.20%~0.25% éœ€é“¾ä¸Šç¡®è®¤
------------------|----------|
å¯¹å†²æˆæœ¬:         |          |
1001x å¼€å¹³ä»“è´¹    | -0.16%   | 0.08% * 2 (æ¯è½®)
1001x æ‰§è¡Œè´¹      | -$0.50   | æ¯æ¬¡å¼€ä»“
1001x èµ„é‡‘è´¹ç‡    | -1~-5%   | åšç©ºé€šå¸¸ä»˜ funding
V2 LP IL          | -2~-10%  | å–å†³äºæ³¢åŠ¨ç‡
ALP mint/burn fee | -0.5~-2% | åŠ¨æ€è´¹ç‡
```

## 9.2 ä¸‰ç§ Regime ä¸‹çš„æ¨¡æ‹Ÿ

### åœºæ™¯ A: CALMï¼ˆä½æ³¢åŠ¨å¸‚åœº, vol < 1%ï¼‰

```
é…æ¯”: ALP 40% / LP 57% / Buffer 3%
å‡è®¾: $100,000 TVL, BTC æ³¢åŠ¨ç‡ 0.5%, ä¸­ç­‰äº¤æ˜“é‡

æ”¶ç›Š:
  ALP (40k):  40,000 * 10% / 365 = $10.96/å¤©
  LP  (57k):  57,000 * 12% / 365 = $18.74/å¤©
  å¯¹å†²æˆæœ¬:   -$2.00/å¤© (ä½é¢‘å†å¹³è¡¡)
  IL:         -$0.50/å¤© (æ³¢åŠ¨å°)
  
å‡€æ”¶ç›Š: ~$27.20/å¤© = ~9.9% APY
```

### åœºæ™¯ B: NORMALï¼ˆæ­£å¸¸å¸‚åœº, 1-3% volï¼‰

```
é…æ¯”: ALP 60% / LP 37% / Buffer 3%
å‡è®¾: $100,000 TVL, BTC æ³¢åŠ¨ç‡ 2%, è¾ƒé«˜äº¤æ˜“é‡

æ”¶ç›Š:
  ALP (60k):  60,000 * 15% / 365 = $24.66/å¤© (äº¤æ˜“é‡å¢åŠ )
  LP  (37k):  37,000 * 15% / 365 = $15.21/å¤©
  å¯¹å†²æˆæœ¬:   -$5.00/å¤© (ä¸­é¢‘å†å¹³è¡¡)
  IL:         -$3.00/å¤© (ä¸­ç­‰æ³¢åŠ¨)
  
å‡€æ”¶ç›Š: ~$31.87/å¤© = ~11.6% APY
```

### åœºæ™¯ C: STORMï¼ˆé«˜æ³¢åŠ¨å¸‚åœº, vol > 3%ï¼‰

```
é…æ¯”: ALP 80% / LP 17% / Buffer 3%
å‡è®¾: $100,000 TVL, BTC æ³¢åŠ¨ç‡ 5%, é«˜äº¤æ˜“é‡+å¤§é‡æ¸…ç®—

æ”¶ç›Š:
  ALP (80k):  80,000 * 25% / 365 = $54.79/å¤© (æ¸…ç®—+æ‰‹ç»­è´¹æš´å¢)
  LP  (17k):  17,000 * 20% / 365 = $9.32/å¤©
  å¯¹å†²æˆæœ¬:   -$10.00/å¤© (é«˜é¢‘å†å¹³è¡¡)
  IL:         -$8.00/å¤© (é«˜æ³¢åŠ¨, ä½† LP ä»“ä½å°)
  
å‡€æ”¶ç›Š: ~$46.11/å¤© = ~16.8% APY

å…³é”®: STORM æ¨¡å¼åè€Œæ”¶ç›Šæœ€é«˜ï¼
å› ä¸º ALP æ˜¯æ³¢åŠ¨ç‡çš„å—ç›Šè€…ã€‚
è¿™å°±æ˜¯ "ALP åŒé‡å¼•æ“" çš„æ ¸å¿ƒä»·å€¼ã€‚
```

### å¯¹æ¯”å›¾

```
APY(%)
  ^
  |
20+                        * STORM(æˆ‘ä»¬)
  |                   *
  |              * NORMAL(æˆ‘ä»¬)
15+         *
  |    * CALM(æˆ‘ä»¬)
  |
10+  - - - - - - - - * - - - - - - - (æŠ€æœ¯æ–‡æ¡£1: å›ºå®šé…æ¯”)
  |              *          *
  |         *                    *
 5+    *                              * (å›ºå®šé…æ¯”åœ¨STORMä¸‹æ”¶ç›Šä¸‹é™)
  |
  +----+----+----+----+----+----+---> æ³¢åŠ¨ç‡(%)
       1    2    3    4    5    6
       
  æˆ‘ä»¬çš„æ–¹æ¡ˆ: å…¨å¤©å€™æ­£æ”¶ç›Šï¼Œé«˜æ³¢åŠ¨æ—¶åè€Œæ›´é«˜
  å›ºå®šé…æ¯”:   é«˜æ³¢åŠ¨æ—¶ IL ä¾µèš€æ”¶ç›Š
```

## 9.3 é£é™©è°ƒæ•´åæ”¶ç›Šï¼ˆSharpe Ratio ä¼°ç®—ï¼‰

```
å‡è®¾æ— é£é™©åˆ©ç‡ = 5% (USDT lending)

              | E[Return] | Std[Return] | Sharpe Ratio
--------------+-----------+-------------+-------------
æˆ‘ä»¬(åŠ¨æ€)    |   12.0%   |    4.0%     |    1.75
å›ºå®š80/20     |    9.0%   |    6.0%     |    0.67
çº¯ ALP       |   15.0%   |   10.0%     |    1.00
çº¯ V2 LP     |   12.0%   |   12.0%     |    0.58

ç»“è®º: åŠ¨æ€é…æ¯” + å¯¹å†² -> Sharpe Ratio æœ€ä¼˜
```

## 9.4 æ•æ„Ÿæ€§ä¸æç«¯æƒ…å¢ƒï¼ˆStress & Sensitivityï¼‰

å¿…é¡»åœ¨ ECONOMICS.md è¡¥å……ä»¥ä¸‹åŒºé—´åˆ†æ:

1. Pancake V2 fee: 0.20% ä¸ 0.25% ä¸¤ç§æƒ…æ™¯

2. Funding: -5% ~ +2% åŒºé—´å¯¹å‡€æ”¶ç›Šå½±å“

3. Gas spike: 50 / 200 / 500 gwei å¯¹ cycle é¢‘ç‡ä¸ bounty çš„å½±å“

4. å•è¾¹è¡Œæƒ…: BTC å•è¾¹ 30% å˜åŠ¨æ—¶ ALP NAV ä¸‹è¡Œå‹åŠ›

5. ä½æµåŠ¨æ€§: Flash Swap æˆæœ¬ä¸Šå‡å¯¹å†å¹³è¡¡ç­–ç•¥çš„å½±å“

è¾“å‡ºè¦æ±‚:

- æ¯ä¸ªæƒ…æ™¯ç»™å‡ºå‡€æ”¶ç›ŠåŒºé—´ (min/avg/max)

- æ ‡æ³¨è§¦å‘ ONLY_UNWIND çš„æ¡ä»¶ä¸ç»“æœ

---

<a id="part10"></a>
# ç¬¬åéƒ¨åˆ†ï¼šæµ‹è¯•è®¡åˆ’

## 10.1 æµ‹è¯•ç¯å¢ƒ

```
æ¡†æ¶: Foundry (forge)
ç½‘ç»œ: BSC mainnet fork
å›ºå®šåŒºå—: éœ€é€‰æ‹©ä¸€ä¸ªè¿‘æœŸåŒºå—å·ï¼ˆç¡®ä¿ ALP/1001x åˆçº¦æ´»è·ƒï¼‰
RPC: BSC å…¬å…± RPC æˆ– Ankr/Quicknode
```

## 10.2 Fork æµ‹è¯•ç”¨ä¾‹

### ç”¨ä¾‹ A: deposit -> cycle -> èµ„äº§éƒ¨ç½²

```
æ­¥éª¤:
  1. ç»™æµ‹è¯•è´¦æˆ· 100,000 USDT
  2. deposit(100_000e18)
  3. cycle()

æ–­è¨€:
  [x] vault çš„ ALP ä½™é¢ > 0 (Integrate)
  [x] vault çš„ V2 LP ä½™é¢ > 0 (Stack)
  [x] vault åœ¨ 1001x ä¸Šæœ‰ short ä»“ä½ (Protect)
  [x] cycle() è°ƒç”¨è€…æ”¶åˆ° bounty (Automate)
  [x] currentRegime != æœªåˆå§‹åŒ–
  [x] totalAssets() ~= 100,000 USDT (æ‰£é™¤è´¹ç”¨)
```

### ç”¨ä¾‹ B: ä»·æ ¼å˜åŒ–å cycle() è‡ªåŠ¨å†å¹³è¡¡

```
æ­¥éª¤:
  1. æ‰§è¡Œç”¨ä¾‹ A
  2. åœ¨ Pancake V2 ä¸Šåšå¤§é¢ swap æ”¹å˜ä»·æ ¼ (æ¨¡æ‹Ÿæ³¢åŠ¨)
  3. warp +6 åˆ†é’Ÿ (è¶…è¿‡ minCycleInterval)
  4. cycle()

æ–­è¨€:
  [x] netDelta ä»è¶… band å›åˆ° band å†…
  [x] 1001x ä»“ä½ä»å­˜åœ¨ï¼ˆæœªè¢«æ¸…ç®—ï¼‰
  [x] äº‹ä»¶ CycleExecuted æ­£ç¡®è®°å½• netDeltaBefore/After
```

### ç”¨ä¾‹ C: Regime åˆ‡æ¢

```
æ­¥éª¤:
  1. æ‰§è¡Œç”¨ä¾‹ A (å‡è®¾åˆå§‹ä¸º NORMAL)
  2. è¿ç»­åšå¤šç¬”å¤§é¢ swap åˆ¶é€ é«˜æ³¢åŠ¨
  3. å¤šæ¬¡ cycle() è®© VolatilityOracle ç§¯ç´¯å¿«ç…§
  4. éªŒè¯ Regime åˆ‡æ¢åˆ° STORM

æ–­è¨€:
  [x] emit RegimeSwitched(NORMAL, STORM, ...)
  [x] ALP é…æ¯”å¢åŠ åˆ° ~80%
  [x] LP é…æ¯”å‡å°‘åˆ° ~17%
```

### ç”¨ä¾‹ D: èµå›é˜Ÿåˆ— (ALP 48h å†·å´)

```
æ­¥éª¤:
  1. deposit -> cycle (éƒ¨ç½²èµ„äº§ï¼ŒåŒ…æ‹¬ mintAlp)
  2. ç«‹åˆ» requestWithdraw(å…¨éƒ¨ shares)
  3. ç«‹åˆ» claimWithdraw -> é¢„æœŸéƒ¨åˆ†æˆåŠŸ(LP+buffer)ï¼ŒALP éƒ¨åˆ† pending
  4. warp +49 hours
  5. å†æ¬¡ claimWithdraw

æ–­è¨€:
  [x] ç¬¬ä¸€æ¬¡ claim: æ‹¿åˆ°éƒ¨åˆ† USDT (æ¥è‡ª LP + buffer)
  [x] ç¬¬äºŒæ¬¡ claim: æ‹¿åˆ°å‰©ä½™ USDT (æ¥è‡ª burn ALP)
  [x] å…¨è¿‡ç¨‹æ— ç®¡ç†å‘˜ä»‹å…¥
  [x] ç”¨æˆ·æœ€ç»ˆæ‹¿åˆ°çš„ USDT ~= åˆå§‹ deposit (æ‰£é™¤è´¹ç”¨)
```

### ç”¨ä¾‹ E: Flash Rebalance

```
æ­¥éª¤:
  1. æ‰§è¡Œç”¨ä¾‹ A (NORMAL regime)
  2. åˆ¶é€ å¤§æ³¢åŠ¨è®© regime åˆ‡æ¢åˆ° STORM
  3. cycle() è§¦å‘ Flash Rebalance

æ–­è¨€:
  [x] å•ç¬”äº¤æ˜“å†…å®Œæˆå†å¹³è¡¡
  [x] æ–°é…æ¯”æ¥è¿‘ STORM ç›®æ ‡ (80/17/3)
  [x] delta åœ¨ band å†…
  [x] æ— ä¸´æ—¶æ•å£ï¼ˆæ£€æŸ¥äº¤æ˜“å†…éƒ¨çŠ¶æ€ï¼‰
```

### ç”¨ä¾‹ F: Bounty æ¿€åŠ±

```
æ­¥éª¤:
  1. deposit -> cycle (åˆå§‹éƒ¨ç½²)
  2. warp +1å¤© (ç§¯ç´¯æ”¶ç›Š)
  3. ç”¨ä¸åŒåœ°å€è°ƒç”¨ cycle()

æ–­è¨€:
  [x] è°ƒç”¨è€… USDT ä½™é¢å¢åŠ  (æ”¶åˆ° bounty)
  [x] bounty >= estimatedGasCost * 1.5
  [x] bounty <= totalValue * 0.5%
```

## 10.3 ä¸å˜é‡æµ‹è¯•

```solidity
// Invariant 1: totalAssets >= totalSupply å¯¹åº”çš„æœ€ä½ä»·å€¼
// (å³ share ä»·æ ¼ä¸èƒ½æ— é™ä¸‹è·Œ)
function invariant_shareValueFloor() external {
    uint256 totalAssets = vault.totalAssets();
    uint256 totalSupply = vault.totalSupply();
    if (totalSupply > 0) {
        assert(totalAssets * 1e18 / totalSupply >= MINIMUM_SHARE_VALUE);
    }
}

// Invariant 2: æ— èµ„é‡‘æ³„éœ²
// vault ç®¡ç†çš„æ€»èµ„äº§ = ALPä»·å€¼ + LPä»·å€¼ + å¯¹å†²ä»·å€¼ + cash
function invariant_noFundLeak() external {
    uint256 expected = vault.totalAssets();
    uint256 actual = alpValue + lpValue + hedgeValue + cashBalance;
    assert(actual >= expected * 99 / 100); // å…è®¸ 1% è¯¯å·®ï¼ˆè´¹ç”¨/ç²¾åº¦ï¼‰
}

// Invariant 3: æ— ç®¡ç†å‘˜
function invariant_noAdmin() external {
    // å°è¯•è°ƒç”¨æ‰€æœ‰å¯èƒ½çš„ admin å‡½æ•° -> å…¨éƒ¨ revert
    try vault.setParams(...) { assert(false); } catch {}
    try vault.sweep(...) { assert(false); } catch {}
    try vault.upgradeTo(...) { assert(false); } catch {}
}
```

---

<a id="part11"></a>
# ç¬¬åä¸€éƒ¨åˆ†ï¼šéªŒæ”¶æ¡ä»¶

## 11.1 å»ä¸­å¿ƒåŒ–/éæ‰˜ç®¡éªŒæ”¶ï¼ˆé¢˜ç›®ç¡¬çº¦æŸï¼Œä¸é€šè¿‡=æ·˜æ±°ï¼‰

```
[  ] EngineVault æ—  ownerã€adminã€multisig gate
[  ] ä¸å­˜åœ¨ onlyOwner / onlyRole ä¿®é¥°çš„å…³é”®å‡½æ•°
[  ] cycle() å®Œå…¨ permissionless
[  ] claimWithdraw() å®Œå…¨ permissionless
[  ] ä¸ä¾èµ–é“¾ä¸‹ API key / agent private key
[  ] ä¸ä¾èµ– Infinity farms backend / Merkle root
[  ] ä¸ä¾èµ– Chainlink keeper / Gelato
[  ] ä¸ä½¿ç”¨ asUSDF (æ¶‰åŠ Ceffu æ‰˜ç®¡)
[  ] ä¸ä½¿ç”¨ Aster Pro API
[  ] æ™ºèƒ½åˆçº¦æ˜¯å”¯ä¸€çœŸç›¸æº
```

## 11.2 åŠŸèƒ½éªŒæ”¶

### Integrateï¼ˆAsterDEX Earn = ä¸»æ”¶ç›Šæºï¼‰
```
[  ] ALP æ˜¯ä¸»è¦æ”¶ç›Šèµ„äº§ï¼ˆé…æ¯” 40-80%ï¼‰
[  ] fork test è¯æ˜ mintAlp æˆåŠŸ
[  ] ALP NAV å˜åŒ–åæ˜ åœ¨ totalAssets() ä¸­
[  ] ALP åŒæ—¶ç”¨ä½œæ³¢åŠ¨ç‡å¯¹å†²ï¼ˆåŒé‡å¼•æ“åˆ›æ–°ï¼‰
```

### Stackï¼ˆPancakeSwap å¯ç»„åˆæ”¶ç›Šå †å ï¼‰
```
[  ] V2 LP æä¾›é¢å¤–æ”¶ç›Šå±‚
[  ] 0.17% æ‰‹ç»­è´¹è‡ªåŠ¨å›æ³¨
[  ] LP ä»½é¢è®¡ç®—æ­£ç¡®ï¼ˆamtBase, amtQuoteï¼‰
```

### Automateï¼ˆå®Œå…¨è‡ªåŠ¨åŒ–ï¼‰
```
[  ] cycle() ç¡®å®šæ€§æ‰§è¡Œï¼ˆç»™å®šé“¾ä¸ŠçŠ¶æ€ -> ç¡®å®šè¾“å‡ºï¼‰
[  ] VolatilityOracle çº¯é“¾ä¸Šï¼ˆæ— å¤–éƒ¨ oracle ä¾èµ–ï¼‰
[  ] Regime Switching è‡ªåŠ¨ï¼ˆCALM / NORMAL / STORMï¼‰
[  ] Flash Rebalance åŸå­æ“ä½œ
[  ] bounty æ¿€åŠ±ç¬¬ä¸‰æ–¹è°ƒç”¨
```

### Protectï¼ˆä¿æŠ¤å±‚ï¼‰
```
[  ] 1001x delta hedge å·¥ä½œæ­£å¸¸
[  ] netDelta åœ¨ band å†…
[  ] MEV ä¿æŠ¤ï¼ˆæ»‘ç‚¹+deadlineï¼‰
[  ] Circuit breaker è§„åˆ™ç”Ÿæ•ˆ
[  ] WithdrawalQueue æ— ç®¡ç†å‘˜è¿ä½œ
```

## 11.3 ä»£ç è´¨é‡éªŒæ”¶

```
[  ] ç§æœ‰ GitHub ä»“åº“ï¼Œæäº¤å†å²æ¸…æ™°
[  ] åˆçº¦æŒ‰æ¨¡å—åˆ†å±‚ï¼ˆcore/adapters/interfaces/libsï¼‰
[  ] æ‰€æœ‰å…¬å…±å‡½æ•°æœ‰ NatSpec
[  ] slither / forge fmt / solhint é€šè¿‡
[  ] fork test å…¨ç»¿ï¼ˆç”¨ä¾‹ A-Fï¼‰
[  ] ä¸å˜é‡æµ‹è¯•é€šè¿‡
```

## 11.4 Demo éªŒæ”¶ï¼ˆ3 åˆ†é’Ÿè§†é¢‘ï¼‰

```
[  ] 0:00-0:30  å±•ç¤ºåˆçº¦æ—  owner/adminï¼ˆetherscan éªŒè¯ï¼‰
[  ] 0:30-1:00  å±•ç¤º deposit USDT -> vault shares
[  ] 1:00-1:30  å±•ç¤º cycle() è‡ªåŠ¨éƒ¨ç½² ALP + LP + å¯¹å†²
[  ] 1:30-2:00  å±•ç¤º Regime åˆ‡æ¢ + Flash Rebalance
[  ] 2:00-2:30  å±•ç¤ºä»»æ„åœ°å€è°ƒç”¨ cycle() é¢†å– bounty
[  ] 2:30-3:00  å±•ç¤º delta åç¦»è¢«æ‹‰å› + èµå›é˜Ÿåˆ—
```

## 11.5 æ–‡æ¡£éªŒæ”¶ï¼ˆREADME.md å¿…é¡»åŒ…å«ï¼‰

```
[  ] Why: è®¾è®¡å“²å­¦ï¼ˆALP åŒé‡å¼•æ“ã€æ³¢åŠ¨ç‡å¯¹å†²ç†è®ºï¼‰
[  ] What: æ ¸å¿ƒç­–ç•¥ï¼ˆä¸‰å±‚æ¶æ„ã€Regime Switchingï¼‰
[  ] How: æŠ€æœ¯å®ç°ï¼ˆFlash Rebalanceã€permissionless cycleï¼‰
[  ] Assumptions: æŒ‘æˆ˜äº†ä»€ä¹ˆå‡è®¾ï¼ˆALP åªèƒ½åšæ”¶ç›Šï¼ŸLP æ˜¯çº¯äºï¼Ÿï¼‰
[  ] Sustainability: ç»æµæ¨¡å‹å’Œæ”¶ç›Šæ¨¡æ‹Ÿ
[  ] Resilience: STORM æ¨¡å¼ä¸‹åè€Œæ›´èµšï¼ˆæ ¸å¿ƒå–ç‚¹ï¼‰
```

---

<a id="part12"></a>
# ç¬¬åäºŒéƒ¨åˆ†ï¼šæ–½å·¥ä»»åŠ¡æ‹†åˆ†ï¼ˆæŒ‰ä¼˜å…ˆçº§ï¼‰

## Task 0ï¼ˆDay 1 ä¸Šåˆï¼‰ï¼šç¯å¢ƒ + æ¥å£

```
[  ] åˆå§‹åŒ– Foundry é¡¹ç›® (forge init)
[  ] æ‹‰å–/å¯¼å‡º Aster diamond ABIï¼ˆLouper CLIï¼‰
[  ] å†™ IAsterDiamond.solï¼ˆä»… P0 æ‰€éœ€å‡½æ•°ï¼‰
[  ] å†™ IPancakeRouterV2.sol / IPancakePairV2.sol
[  ] å†™ Foundry fork æµ‹è¯•æ¡†æ¶ï¼ˆå›ºå®š blockNumberï¼‰
[  ] é“¾ä¸Šç¡®è®¤ Pancake V2 è´¹ç‡ä¸ INIT_CODE_HASH
[  ] é“¾ä¸Šç¡®è®¤ ALP burn cap å…¬å¼ä¸ cooling ç»†èŠ‚
[  ] ç¡®è®¤ 1001x funding/price ç²¾åº¦
[  ] éªŒè¯: èƒ½åœ¨ fork ä¸Šè¯»å– ALP ä½™é¢ã€V2 reservesã€1001x ä»“ä½
é¢„ä¼°: 3-4 å°æ—¶
```

## Task 1ï¼ˆDay 1 ä¸‹åˆï¼‰ï¼šPancakeV2Adapter

```
[  ] addLiquidity / removeLiquidity
[  ] getUnderlyingAmounts (LP ä»½é¢æ‹†è§£)
[  ] getSpotPrice
[  ] å•å…ƒæµ‹è¯• + fork æµ‹è¯•
é¢„ä¼°: 2-3 å°æ—¶
```

## Task 2ï¼ˆDay 2 ä¸Šåˆï¼‰ï¼šAsterAlpAdapter

```
[  ] mintAlp / burnAlp
[  ] getAlpBalance / getAlpNAV
[  ] canBurn (å†·å´æœŸæ£€æŸ¥)
[  ] fork æµ‹è¯•: mint æˆåŠŸ / 48h å†… burn revert / 48h å burn æˆåŠŸ
é¢„ä¼°: 3-4 å°æ—¶
```

## Task 3ï¼ˆDay 2 ä¸‹åˆï¼‰ï¼šAster1001xAdapter

```
[  ] openShort / closeTrade / addMargin
[  ] getPositions / getHedgeBaseQty
[  ] usdToQty / baseToQty ç²¾åº¦è½¬æ¢
[  ] fork æµ‹è¯•: å¼€ä»“->è¯»ä»“ä½->å¹³ä»“->ä»“ä½æ¶ˆå¤±
é¢„ä¼°: 4-5 å°æ—¶ï¼ˆABI å¯¹é½å¯èƒ½è€—æ—¶ï¼‰
```

## Task 4ï¼ˆDay 3ï¼‰ï¼šVolatilityOracle + Regime

```
[  ] recordSnapshot
[  ] getVolatilityBps
[  ] getRegime
[  ] minSnapshotInterval + MIN_SAMPLES å†·å¯åŠ¨é€»è¾‘
[  ] é‡‡æ ·ä¸è¶³æ—¶ Regime = NORMAL
[  ] æµ‹è¯•: æ¨¡æ‹Ÿä¸åŒæ³¢åŠ¨ç‡ -> éªŒè¯ regime åˆ‡æ¢
é¢„ä¼°: 2-3 å°æ—¶
```

## Task 5ï¼ˆDay 3-4ï¼‰ï¼šEngineVault æ ¸å¿ƒ

```
[  ] ERC-4626 (deposit/redeem/totalAssets/convertToShares)
[  ] cycle() ä¸»å¾ªç¯
[  ] _computeTargetAllocation()
[  ] _rebalanceAssets()
[  ] _rebalanceHedge()
[  ] _calculateBounty()
[  ] bounty gasPrice cap + cashBuffer cap
[  ] äº‹ä»¶: CycleExecuted, RegimeSwitched
[  ] fork æµ‹è¯•: ç”¨ä¾‹ A + B
é¢„ä¼°: 6-8 å°æ—¶
```

## Task 6ï¼ˆDay 4ï¼‰ï¼šFlashRebalancer

```
[  ] pancakeCall å›è°ƒ
[  ] executeFlashRebalance
[  ] fork æµ‹è¯•: ç”¨ä¾‹ E (Flash Rebalance)
é¢„ä¼°: 4-5 å°æ—¶
```

## Task 7ï¼ˆDay 4-5ï¼‰ï¼šWithdrawalQueue

```
[  ] requestWithdraw / claimWithdraw
[  ] _attemptLiquidation (ä¼˜å…ˆçº§é‡Šæ”¾)
[  ] claimWithdraw æ¿€åŠ± (å°é¢ bounty)
[  ] partial claim è®°å½•ä¸å»é‡
[  ] fork æµ‹è¯•: ç”¨ä¾‹ D (48h å†·å´)
é¢„ä¼°: 3-4 å°æ—¶
```

## Task 8ï¼ˆDay 5ï¼‰ï¼šé›†æˆ + å®‰å…¨ + æ–‡æ¡£

```
[  ] å…¨é“¾è·¯ fork æµ‹è¯• (A-F å…¨ç»¿)
[  ] ä¸å˜é‡æµ‹è¯•
[  ] slither æ‰«æ + ä¿®å¤
[  ] Circuit breaker å®ç°
[  ] ONLY_UNWIND ç†”æ–­æ¨¡å¼ + è§£é™¤æ¡ä»¶
[  ] README.md (è®¾è®¡å“²å­¦ + ç­–ç•¥é€»è¾‘)
[  ] ARCHITECTURE.md
[  ] THREAT_MODEL.md
[  ] ECONOMICS.md (æ”¶ç›Šæ¨¡æ‹Ÿ + æ•æ„Ÿæ€§/å‹åŠ›æµ‹è¯•)
é¢„ä¼°: 6-8 å°æ—¶
```

## Task 9ï¼ˆDay 6ï¼‰ï¼šDemo + æ‰“ç£¨

```
[  ] å½•åˆ¶ 3 åˆ†é’Ÿ Demo è§†é¢‘
[  ] æœ€ç»ˆå®‰å…¨å®¡æŸ¥
[  ] Gas ä¼˜åŒ–ï¼ˆå¦‚æœ‰æ—¶é—´ï¼‰
[  ] æäº¤åˆ° DoraHacks
é¢„ä¼°: 4-6 å°æ—¶
```

---

# é™„å½• Aï¼šè®¾è®¡å“²å­¦æ‘˜è¦ï¼ˆREADME.md æ ¸å¿ƒå†…å®¹ï¼‰

## Why This Design?

### The Dual Engine Insight

Most DeFi vaults treat yield and risk as separate problems.
We discovered that ALP is inherently BOTH:

1. A yield engine (trading fees + funding + liquidations)
2. A volatility hedge (benefits from the same conditions that hurt LPs)

This means ALP doesn't just generate yield -- it PROTECTS the portfolio
during market stress. When markets crash and LPs suffer impermanent loss,
ALP captures increased trading volume and liquidation proceeds.

### The Self-Driving Philosophy

A truly autonomous system shouldn't just execute -- it should ADAPT.

Our engine has three operating modes (CALM / NORMAL / STORM) that shift
capital allocation based on on-chain realized volatility. No oracle
dependency. No human judgment. Pure math.

### Why Flash Rebalance?

Traditional rebalancing exposes the vault to MEV and price drift across
multiple transactions. Our Flash Rebalance executes the entire portfolio
restructuring in a single atomic transaction -- zero temporary exposure,
zero MEV surface.

### Assumptions We Challenged

1. "ALP is just a yield product" -> No, it's also a hedge
2. "Higher volatility = worse returns" -> Not with adaptive allocation
3. "You need Chainlink for automation" -> On-chain TWAP is sufficient
4. "Flash loans are only for arbitrage" -> They're great for rebalancing
5. "Fixed allocation is simpler" -> Dynamic allocation is also simple with regime switching

---

# é™„å½• Bï¼šå…³é”®å‚è€ƒ

```
AsterDEX:
  - 1001x åˆçº¦(BSC Diamond): 0x1b6f2d3844c6ae7d56ceb3c3643b9060ba28feb0
  - 1001x å¼€/å¹³ä»“è´¹: 0.08%, æ‰§è¡Œè´¹: $0.50
  - ALP mint å 48h å†·å´, burn cap å…¬å¼
  - Funding per block è®¡ç®—
  - USDF Contract: 0x33bf30Bd19D176454C49F035f2E4942379B73d11

PancakeSwap:
  - Router V2: 0x10ED43C718714eb63d5aA57B78B54704E256024E
  - Factory V2: 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73
  - V2 Fee: 0.20%~0.25% total (éœ€é“¾ä¸Šç¡®è®¤), 0.17% to LP (auto-compound)
  - V3 Fee: éœ€æ‰‹åŠ¨ claim (ä¸ç”¨äº P0)
  - INIT_CODE_HASH: 0x00fb7f630766e6a...

BSC Tokens:
  - USDT:  0x55d398326f99059fF775485246999027B3197955
  - BTCB:  0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c
  - WBNB:  0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c
  - CAKE:  0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82
```

---

# é™„å½• C: ä¸æŠ€æœ¯æ–‡æ¡£1çš„å…³é”®å·®å¼‚æ€»ç»“

```
+================================+============================+
| æŠ€æœ¯æ–‡æ¡£1                      | æŠ€æœ¯æ–¹æ¡ˆ2 (æœ¬æ–‡æ¡£)         |
+================================+============================+
| å›ºå®š 80% ALP / 20% LP         | åŠ¨æ€ 40-80% ALP / 17-57% LP|
| æ—  Regime Switching            | 3æ¡£ Regime (CALM/NORMAL/STORM)|
| æ—  Flash Loan                  | Flash Swap åŸå­å†å¹³è¡¡       |
| ALP ä»…åšæ”¶ç›Š                   | ALP åŒé‡å¼•æ“(æ”¶ç›Š+å¯¹å†²)    |
| ç®€å•å›ºå®š bounty                | åˆ©æ¶¦åˆ†æˆ + æœ€ä½ä¿éšœ bounty  |
| æ—  bounty é˜²åˆ·                | gasPrice cap + buffer cap  |
| æ—  MEV ä¿æŠ¤                    | æ»‘ç‚¹ä¿æŠ¤ + deadline + Flash  |
| æ—  TWAP å†·å¯åŠ¨ä¿æŠ¤            | MIN_SAMPLES å†·å¯åŠ¨ä¿æŠ¤      |
| ç†”æ–­ç›´æ¥ revert               | ONLY_UNWIND æ¨¡å¼ (ä¸é”æ­»)   |
| æ— èµå›æ¿€åŠ±                    | claim bounty + partial claim |
| æ—  circuit breaker             | NAVæš´è·Œ+ä»·æ ¼åå·®è‡ªåŠ¨ç†”æ–­    |
| æ— ç»æµæ¨¡å‹                     | ä¸‰åœºæ™¯æ”¶ç›Šæ¨¡æ‹Ÿ + Sharpe     |
| æ— æ³¢åŠ¨ç‡è®¡ç®—                   | é“¾ä¸ŠTWAPæ³¢åŠ¨ç‡Oracle        |
| å•ä¸€äº¤æ˜“å¯¹å‡è®¾                 | å¯æ‰©å±•å¤špairæ¶æ„            |
+================================+============================+
```

---

æ–‡æ¡£ç»“æŸã€‚
ç‰ˆæœ¬: v2.0 | æ—¥æœŸ: 2026-02-22 | ä½œè€…: Self-Driving Yield Engine Team
